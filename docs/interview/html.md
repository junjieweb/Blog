# HTML 面试题



### **对 web worker 的理解**

- JavaScript 语言采用的是单线程模型，Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。

  JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU
  的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker
  线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

如何创建 web worker：

1. 检测浏览器对于 web worker 的支持性

2. 创建 web worker 文件（js，回传函数等）

3. 创建 web worker 对象

### **HTML5的离线储存怎么使用，它的工作原理是什么**

- 离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。

  原理：HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)
  ，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示

  使用方法：

  （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：

  `<html lang="en" manifest="index.manifest">`

  （2）在 cache.manifest 文件中编写需要离线存储的资源：

```
  CACHE MANIFEST

       #v0.11
       
       CACHE:
       
       js/app.js
       
       css/style.css
       
       NETWORK:
       
       resourse/logo.png
       
       FALLBACK:
       
       / /offline.html
```

● CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。

● NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说
CACHE 的优先级更高。

● FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。

（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。

如何更新缓存：

（1）更新 manifest 文件

（2）通过 javascript 操作

（3）清除浏览器缓存

注意事项：

    （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。

    （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。

    （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。

    （4）FALLBACK 中的资源必须和 manifest 文件同源。

    （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。

    （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。

    （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。

### ** 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？**

- 在线情况下：浏览器发现 html 头部有 manifest 属性，它会请求 manifest
  文件。第一次访问页面，会根据manidest内容下载相应资源并存储，不是第一次根据离线资源加载页面，并对比新旧manifest，未改变不做修改，改变了下载新的资源并进行存储
- 离线情况下：加载离线资源

### **title与h1的区别、b与strong的区别、i与em的区别？**

- strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。
- title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响
- i内容展示为斜体，em表示强调的文本

### **iframe标签 有那些优点和缺点？**

- iframe作用：iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。
- 优点： ● 用来加载速度较慢的内容（如广告）
  ● 可以使脚本可以并行下载
  ● 可以实现跨子域通信
- 缺点： ● iframe 会阻塞主页面的 onload 事件
  ● 无法被一些搜索引擎索识别
  ● 会产生很多页面，不容易管理

### **label 的作用是什么？如何使用？**

- 作用：label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。
- 使用方法：`<label for="mobile">Number:</label>`
  `<input type="text" id="mobile"/>`

### **Canvas和SVG的区别**

- SVG

    - SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG
      DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。
    - 其特点如下：

        - ● 不依赖分辨率
        - ● 支持事件处理器
        - ● 最适合带有大型渲染区域的应用程序（比如谷歌地图）
        - ● 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
        - ● 不适合游戏应用

- Canvas

    - Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。
    - 其特点如下：

        - ● 依赖分辨率
        - ● 不支持事件处理器
        - ● 弱的文本渲染能力
        - ● 能够以 .png 或 .jpg 格式保存结果图像
        - ● 最适合图像密集型的游戏，其中的许多对象会被频繁重绘

### **head 标签有什么作用，其中什么标签必不可少？**

- 作用：`<head>` 标签用于定义文档的头部，它是所有头部元素的容器。`<head>` 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web
  中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。
- 可包含的标签：下面这些标签可用在 head 部分：`<base>, <link>, <meta>, <script>, <style>, <title>`。 其中只有title是必须的

### **文档声明（Doctype）和<!Doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义?**

严格模式与混杂模式的区分：
● 严格模式： 又称为标准模式，指浏览器按照W3C标准解析代码；
● 混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；
区分：网页中的DTD，直接影响到使用的是严格模式还是浏览模式，可以说DTD的使用与这两种方式的区别息息相关。
● 如果文档包含严格的DOCTYPE ，那么它一般以严格模式呈现（严格 DTD ——严格模式）；
● 包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡
DTD ——混杂模式）；
● DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现（DTD不存在或者格式不正确——混杂模式）；
● HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(HTML5 没有严格和混杂之分)。
总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。

- 文档声明的作用：文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。

- `<!Doctype html>`的作用：`<!doctype html>` 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。

### **浏览器乱码的原因是什么？如何解决？**

- 产生乱码的原因： ● 网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码；
  ● html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码；
  ● 浏览器不能自动检测网页编码，造成网页乱码。
- 解决方式： ● 使用软件编辑HTML网页内容；
  ● 如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进行程序转码；
  ● 如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。

### **渐进增强和优雅降级之间的区别**

两者区别：
● 优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；
● 降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。
“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。
在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。
“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被
Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。

- 渐进增强：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。
- 优雅降级：一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。

### **说一下 HTML5 drag API （拖放）**

- dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。
- drag：事件主体是被拖放元素，在正在拖放被拖放元素时触发。
- dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。
- dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
- dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。
- drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。在一个拖动过程中，释放鼠标键时触发此事件
- dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。

### **html与XML**

- html是超文本标记语言，是一种描述性语言，用html可以创建能在互联网上传输的信息页，是构成网页文档的主要内容，由很多标签组成
- XML可扩展标记语言，是互联网环境中跨平台、基于内容的技术，是当前处理结构类文档信息的强有力的工具，适合作为各种存储与共享的通用平台，是对html的补充

