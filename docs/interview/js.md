# JavaScript 面试

## **1.数据类型**

### **JavaScript有哪些数据类型，它们的区别？**

- 数据类型

    - 基本数据类型

        - 字符串String
        - 数字型Number
        - 布尔型Boolean
        - 未定义undefined
        - Null
        - Symbol

    - 引用数据类型

        - 对象型Object
        - 数组型Array
        - 函数型Function
        - Date
        - Math
        - 正则RegExp
        - Map
        - Set

- 区别

    - 两种类型的区别在于存储位置的不同

        - 基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储
        - 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

### **数据类型检测的方式有哪些**

- typeof xxx

    - 用于检测基本数据类型（除Null外，Null会被检测为object）
    - 检测引用数据类型除（除function外，function会被检测为function）会被检测为object
    - 返回结果为字符串类型，且类型第一个字母均为小写

        -

- xxx instanceof constructor

    - 适用于精准检测引用数据类型

        - 可以正确判断对象的类型，用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，object instanceof constructor，object为实例对象，constructor为构造函数

            -

- Object.prototype.toString.call()

    - 适用于所有数据类型

        - 调用该方法，统一返回格式“[object Xxx]”的字符串

            -

### **判断数组的方式有哪些**

- xxx instanceof constructor

    - 返回布尔值

- Object.prototype.toString.call( )

    - 返回“[object Xxx]”的字符串

- 数组.__proto__ === Array.prototype(通过原型链做判断)

    - 返回布尔值

- 通过ES6的Array.isArray()做判断

    - 返回布尔值

- 通过Array.prototype.isPrototypeOf(数组名）

    - 返回布尔值

### **null和undefined区别**

- 首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。
- undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。

### **如何获取安全的 undefined 值？**

- 因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。

### **typeof NaN 的结果是什么？**

- NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。返回的结果为"number"，NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。

### ** isNaN 和 Number.isNaN 函数的区别？**

- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

    -

### **== 操作符的强制类型转换规则？**

-

    - 首先会判断两者类型是否相同，相同的话就比较两者的大小；
    - 类型不相同的话，就会进行类型转换；
    - 会先判断是否在对比 null 和 undefined，是的话就会返回 true
    - 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number
    - 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断
    - 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断

### **其他值到字符串的转换规则？**

- Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"
- Boolean 类型，true 转换为 "true"，false 转换为 "false"
- Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式
- Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误
- 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值

### **其他值到数字值的转换规则？**

为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。

- Undefined 类型的值转换为 NaN
- Null 类型的值转换为 0
- Boolean 类型的值，true 转换为 1，false 转换为 0
- String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0
- Symbol 类型的值不能转换为数字，会报错
- 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字
- 总结

    - 如果值有toString（）方法，则调用该方法并返回结果；null返回“null”，undefined返回“undefined”

### **其他值到布尔类型的值的转换规则？**

- false

    - undefined
    - null
    - false
    - +0、-0 和 NaN
    - ""

- true

    - 除以上外

### **|| 和 && 操作符的返回值？**

- || 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。

    - 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。
    - && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

### **Object.is(value1, value2) 与比较操作符 “===”、“==” 的区别？**

- 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较
- 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false
- 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的

### **什么是 JavaScript 中的包装类型？**

- 在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：

    -

        - 在访问'abc'.length时，JavaScript 将'abc'在后台转换成String('abc')，然后再访问其length属性。
        - JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：

            -

        - 也可以使用valueOf方法将包装类型倒转成基本类型：

            -

### **+操作符什么时候用于字符串的拼接？**

- 根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

### **为什么会有BigInt的提案？ **

- avaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。

### **object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别**

- Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。
- 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。

### **如何判断一个对象是空对象**

- 使用JSON自带的JSON.stringify方法来判断

    -

- 使用ES6新增的方法Object.keys()来判断

    -

## **2.ES6**

### **let、const、var的区别**

- 区别主要体现在七个方面

    - 是否有块级作用域

        - 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：

            - 内层变量可能覆盖外层变量
            - 用来计数的循环变量泄露为全局变量

    - 是否存在变量提升

        - var存在变量提升
        - let、const不存在变量提升，即变量只能在声明之后使用，否在会报错

    - 是否添加全局属性

        - 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。

    - 能否重复声明变量

        - var可以重复声明变量，后声明的同名变量会覆盖之前声明的变量
        - const和let不允许重复声明变量

    - 是否存在暂时性死区

        - 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区 let a = a/const a = a（会报错）
        - 使用var声明的变量不存在暂时性死区：var a = a（不会报错）

    - 是否必须设置初始值

        - var和let不需要赋初始值，只声明就可以
        - const声明时必须赋初始值，否则会报错

    - 能否改变指针指向（重复赋值）

        - let创建的变量是可以更改指针指向（可以重新赋值）
        - const声明的变量是不允许改变指针的指向

### **const对象的属性可以修改吗**

- const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量；但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

### **如果new一个箭头函数的会怎么样**

- 箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数；new操作符的实现步骤如下：

1. 创建一个对象
2. 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）
3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）
4. 返回新的对象                                                                                               所以，上面的第二、三步，箭头函数都是没有办法执行的。

### **箭头函数与普通函数的区别**

普通函数：

let fn = function（）{...} 或者 function fn（）{...}

箭头函数：

let fn = （）=> {...}

- 箭头函数比普通函数更加简洁

    - 如果只有一个参数，可以省去参数的括号
    - 如果函数体的返回值只有一句，可以省略大括号，且必须省略return

- 箭头函数没有自己的this

    - 箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。

- call()、apply()、bind()等方法不能改变箭头函数中this的指向

    - 箭头函数的this指向要么是window，要么是他的外层

- 箭头函数不能作为构造函数使用

    - 箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数；new操作符的实现步骤如下：

1. 创建一个对象
2. 将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）
3. 指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）
4. 返回新的对象                                                                                               所以，上面的第二、三步，箭头函数都是没有办法执行的。

- 箭头函数没有自己的arguments

    - 箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。

- 箭头函数没有prototype
- 箭头函数不能用作Generator函数，不能使用yield关键字

### **箭头函数的this指向哪⾥？**

- 箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。箭头函数的this指向外层函数的this

### **扩展运算符的作用及使用场景**

- 对象扩展运算符

    - 对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。扩展运算符对对象实例的拷贝属于浅拷贝

      let obj = {...obj1，obj2}与Object.assign（{}，{}）类似，若后面的对象与前面的对象有同名属性，则后面的覆盖前面的

- 数组扩展运算符

    - 数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

      使用Math函数获取数组中特定的值：

      const numbers = [9, 4, 7, 1];

      Math.min(...numbers); // 1

      Math.max(...numbers); // 9

### **对对象与数组的解构的理解**

- 数组的解构

    - 在解构数组时，以元素的位置为匹配条件来提取想要的数据的

- 对象的解构

    - 在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的

### **如何提取高度嵌套的对象里的指定属性？**

- const school = {
  classes: {
  stu: {
  name: 'Bob',
  age: 24,
  }
  }
  }                                                                                           const { classes: { stu: { name } }} = school

### ** 对 rest 参数的理解**

- 扩展运算符（...args)被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组，便于使用数组的遍历等方法【与arguments类似，但是arguments是以对象形式】

### **ES6中模板语法与字符串处理**

- 允许用${}的方式嵌入变量，优势有两个

    - 在模板字符串中，空格、缩进、换行都会被保留，可以识别html代码
    - 模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算

## **3.JS基础**

### **new操作符的实现原理**

- new操作符的执行过程：
  （1）首先创建了一个新的空对象(创建一个新的内存空间）
  （2）设置原型，将对象的原型设置为函数的 prototype 对象。
  （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
  （4）返回新对象（所以构造函数不需要return）

### **Map和Object的区别**

- 同名碰撞

    - 对象其实就是在堆开辟了一块内存，其实Map的键存的就是这块内存的地址。只要地址不一样，就是两个不同的键，这就解决了同名属性的碰撞问题，而传统的Object显然做不到这一点。

        -

- 键的类型

    - Map的键可以是任意值，包括函数、对象或任意基本类型。
    - Object 的键必须是 String 或是Symbol。

- 键的顺序

    - Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。
    - Object 的键是无序的

- Size

    - Map 的键值对个数可以轻易地通过size 属性获取
    - Object 的键值对个数只能手动计算

- 迭代

    - Map 是 iterable 的，所以可以直接被迭代，可用for...of遍历

        -

    - Object不是 iterable，不可以被迭代，不能用for...of遍历

### **Map和weakMap的区别**

- Map

    - map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。

        - Map数据结构有以下操作方法

            - size

                - map.size 返回Map结构的成员总数

            - set(key,value)

                - 设置键名key对应的键值value，然后返回整个Map结构，如果key是简单数据类型且已经有值，则键值会被更新，否则就新生成该键，若键为引用数据类型，则不会被更改。

            - get(key)

                - 该方法读取key对应的键值，如果找不到key，返回undefined

            - has(key)

                - 该方法返回一个布尔值，表示某个键是否在当前Map对象中

            - delete(key)

                - 该方法删除某个键，返回true，如果删除失败，返回false

            - clear()

                - map.clear()清除所有成员，没有返回值

        - Map结构原生提供三个遍历器生成函数和一个遍历方法

            -

                - keys()

                    - 返回键名的遍历器

                - values()

                    - 返回键值的遍历器

                - entries()

                    - 返回所有成员的遍历器

                - forEach()

                    - 遍历Map的所有成员

- weakMap

    - WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的

        - weakMap对象也有以下几种方法

            - set(key,value)

                - 设置键名key对应的键值value，然后返回整个Map结构

            - get(key)

                - 该方法读取key对应的键值，如果找不到key，返回undefined

            - has(key)

                - 该方法返回一个布尔值，表示某个键是否在当前Map对象中

            - delete(key)

                - 该方法删除某个键，返回true，如果删除失败，返回false

        - WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用

### **JavaScript有哪些内置对象**

- 值属性

    - 这些全局属性返回一个简单值，这些值没有自己的属性和方法。
      例如 Infinity、NaN、undefined、null 字面量

- 函数属性

    - 全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。
      例如 eval()、parseFloat()、parseInt() 等

- 基本对象

    - 基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。
      例如 Object、Function、Boolean、Symbol、Error 等

- 数字和日期对象

    - 用来表示数字、日期和执行数学计算的对象。
      例如 Number、Math、Date

- 字符串

    - 用来表示和操作字符串的对象。
      例如 String、RegExp

- 可索引的集合对象

    - 这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array

- 使用键的集合对象

    - 这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。
      例如 Map、Set、WeakMap、WeakSet

- 矢量集合

    - SIMD 矢量集合中的数据会被组织为一个数据序列。
      例如 SIMD 等

- 结构化数据

    - 这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。
      例如 JSON 等

- 控制抽象对象

    - 例如 Promise、Generator 等

- 反射

    - 例如 Reflect、Proxy

- 国际化

    - 为了支持多语言处理而加入 ECMAScript 的对象。
      例如 Intl、Intl.Collator 等

- WebAssembly
- 其他

    - 例如 arguments

### **常用的正则表达式有哪些？**

-

### **对JSON的理解**

- JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为
  JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。

    - js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理

        - JSON.stringify 函数

            - 通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串

        - JSON.parse() 函数

            - 这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问

### **JavaScript脚本延迟加载的方式有哪些？**

- defer 属性

    - 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。

- async 属性

    - 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。

- 动态创建 DOM 方式

    - 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本

- 使用 setTimeout 延迟方法

    - 设置一个定时器来延迟加载js脚本文件

- 让 JS 最后加载

    - 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行

### **JavaScript 类数组对象的定义？**

- 一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数

    - 常见的类数组转换为数组的方法

        - 通过 call 调用数组的 slice 方法来实现转换

          slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。

            - Array.prototype.slice.call(arrayLike);

        - 通过 call 调用数组的 splice 方法来实现转换

          splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

            - Array.prototype.splice.call(arrayLike, 0);

        - 通过 apply 调用数组的 concat 方法来实现转换

          concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。

            - Array.prototype.concat.apply([], arrayLike);

        - 通过 Array.from 方法来实现转换

          Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

            - Array.from(arrayLike);

### **数组有哪些原生方法？**

- 数组和字符串的转换方法

    - toString()、toLocalString()、join()

- 数组尾部操作的方法

    - pop() 和 push()，push 方法可以传入多个参数

- 数组首部操作的方法

    - shift() 和 unshift() unshift方法可以传递多个参数，表示在数组开头增加

- 重排序的方法

    - reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置

- 数组连接的方法

    - concat() ，返回的是拼接好的数组，不影响原数组

- 数组截取（浅拷贝）办法

    - slice(begin【end】)，用于截取数组中的一部分返回，不影响原数组。

- 数组插入/删除/新增方法

    - array.splice(start[, deleteCount[, item1[, item2[, ...]]]])，改变原数组

- 数组归并方法

    - reduce() 和 reduceRight() 方法

### **Unicode、UTF-8、UTF-16、UTF-32的区别？**

- ● Unicode 是编码字符集（字符集），而UTF-8、UTF-16、UTF-32是字符集编码（编码规则）；
  ● UTF-16 使用变长码元序列的编码方式，相较于定长码元序列的UTF-32算法更复杂，甚至比同样是变长码元序列的UTF-8也更为复杂，因为其引入了独特的代理对这样的代理机制；
  ● UTF-8需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而UTF-16不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；
  ● 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用UTF-8就比UTF-16节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么UTF-16就占优势了，可以节省很多空间；

### **常见的位运算符有哪些？其计算规则是什么？**

- &---与

    - 两个位都为1时，结果才为1

- |---或

    - 两个位都为0时，结果才为0

- ^---异或

    - 两个相应位相同为0，相异为1

- ~---取反

    - 0变1，1变0

- <<---左移

    - 各二进制位全部左移若干位，高位丢弃，低位补0

- >>---右移

    - 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃

### **为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?**

- arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。
- 要遍历类数组的方法

    - 使用call和apply方法

        -

    - Array.from方法将类数组转化成数组

        -

    - 使用展开运算符将类数组转化成数组

        -

### **什么是 DOM 和 BOM？**

- DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。
- BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的方法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象、history对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。

### **对AJAX的理解，实现一个AJAX请求**

- **指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。**

  创建AJAX请求的步骤：

  ● 创建一个 XMLHttpRequest 对象。

  ● 在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。

  ● 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。

  ● 当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。

    -

        - **readyState属性的五个状态**

    -

### **ajax、axios、fetch的区别**

- AJAX

    - 异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：

        - 本身是针对MVC编程，不符合前端MVVM的浪潮
        - 基于原生XHR开发，XHR本身的架构不清晰
        - 不符合关注分离（Separation of Concerns）的原则
        - 配置和调用方式非常混乱，而且基于事件的异步模型不友好

- Axios

    - Axios 是一种基于Promise封装的HTTP客户端，支持浏览器端和 Node.js 端其特点如下

        - 浏览器端发起XMLHttpRequests请求
        - node端发起http请求
        - 支持Promise API
        - 监听请求和返回
        - 对请求和返回进行转化
        - 取消请求
        - 自动转换json数据
        - 客户端支持抵御XSRF攻击

- Fetch

    - fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。

        - 优点

            - 语法简洁，更加语义化
            - 基于标准 Promise 实现，支持 async/await
            - 更加底层，提供的API丰富（request, response）
            - 脱离了XHR，是ES规范里新的实现方式

        - 缺点

            - fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject
            - fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
            - fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
            - fetch没有办法原生监测请求的进度，而XHR可以

### **JavaScript为什么要进行变量提升，它导致了什么问题？**

- 为什么要进行变量提升

    - 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间
    - 声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行

        -

- 变量提升导致的问题

    -

### **ES6模块与CommonJS模块有什么异同？**

- 不同点

    - 1.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
    - 2.CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载
    - 3.CommonJS是对模块的浅拷贝，ES6 Module是对模块的引入，即ES6 Module只存只读，不能改变其值，具体点就是指针指向不能变，类似const 。
    - 4.import的接口是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向。可以对commonJS重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。

- 相同点

    - CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变

### **常见的DOM操作有哪些**

- DOM 节点的获取

    - 通过id获取

        - document.getElementById("id名”）

    - 通过标签名获取

        - document.getElementById("标签名”）

    - 通过类名获取

        - document.getElementByClassName('.类名‘）

    - querySelector获取

        - document.querySelector('#id名/.类名/标签名’）

    - querySelectorAll获取

        - document.querySelectorAll('#id名/.类名/标签名’）

    - 特殊元素获取

        - 获取body元素

            - document.body

        - 获取html元素

            - document.documentElement

- DOM 节点的创建

    - document.createElement('标签名‘）

- DOM 节点的添加

    - 后面添加

        - 父元素名.appendChild（要添加的元素）

    - 指定元素前面添加

        - 父元素名.insertBefore(要添加的元素，添加到哪个元素前面）

- DOM 节点的删除

    - 父节点名.removeChild（子节点名）

- DOM 节点的克隆

    - 要克隆的节点名.cloneNode（true/false）

### **use strict是什么意思 ? 使用它区别是什么？**

- 概念

    - use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。

- 目的

    - 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;
    - 消除代码运行的不安全之处，保证代码运行的安全；
    - 提高编译器效率，增加运行速度；
    - 为未来新版本的 Javascript 做好铺垫

- 区别

    - 禁止使用 with 语句
    - 禁止 this 关键字指向全局对象
    - 对象不能有重名的属性

### **如何判断一个对象是否属于某个类**

- 第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
- 第二种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来判断

### **强类型语言和弱类型语言的区别**

- 强语言类型

    - 强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串

- 弱语言类型

    - 弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换

### **解释性语言和编译型语言的区别**

- 解释型语言

    - 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下

        - 解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低
        - 只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植
        - JavaScript、Python等属于解释型语言

- 编译型语言

    - 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下

        - 一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高
        - 与特定平台相关，一般无法移植到其他平台
        - C、C++等属于编译型语言

### **for...in和for...of的区别 **

for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、字符串、Map、Set、类数组对象【伪数组】等，注意：对象没有iterator）并且返回各项的值

- 区别

    - for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链
    - 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值

### **如何使用for...of遍历对象 **

- for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。

    - 如果需要遍历的对象是类数组对象，用Array.from转成数组即可

        - 输出的为键值

    - 如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可

### **数组的遍历方法有哪些**

- for...of

    - 不改变原数组

        - for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象

- forEach()

    - 视情况是否改变原数组

        - 没有返回值

- filter()

    - 不改变原数组

        - 数组方法，不改变原数组，有返回值，返回一个符合筛选规则的新数组

- every() 和 some()

    - 不改变原数组

        - 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.

- map()

    - 不改变原数组

        - 数组方法，不改变原数组，有返回值，生成一个一一对应的新数组

- find() 和 findIndex()

    - 不改变原数组

        - 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值

- reduce() 和 reduceRight()

    - 不改变原数组

        - 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作

### **forEach和map方法有什么区别**

- forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值
- map()方法不会改变原数组的值，有返回值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值

### **addEventListener()方法的参数和使用**

- 概念

    - EventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Element，Document和Window或者任何其他支持事件的对象。

- 原理

    - 将实现EventListener的函数或对象添加到调用它的EventTarget上的指定事件类型的事件侦听器列表中。

- 语法

    -

        - type

            - 表示监听事件类型的字符串

        - listener

            - 当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数。

        - options 可选

            - 一个指定有关 listener 属性的可选参数对象。可用的选项如下：
              ● capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。
              ● once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。
              ● passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。
              ● signal：AbortSignal，该 AbortSignal 的 abort() 方法被调用时，监听器会被移除。

        - useCapture  可选

            - Boolean，在DOM树中，注册了listener的元素， 是否要先于它下面的EventTarget，调用该listener。 当useCapture(设为true) 时，沿着DOM树向上冒泡的事件，不会触发listener。当一个元素嵌套了另一个元素，并且两个元素都对同一事件注册了一个处理函数时，所发生的事件冒泡和事件捕获是两种不同的事件传播方式。事件传播模式决定了元素以哪个顺序接收事件。如果没有指定， useCapture 默认为 false 。

        - wantsUntrusted

            - 如果为 true , 则事件处理程序会接收网页自定义的事件。此参数只适用于 Gecko（chrome的默认值为true，其他常规网页的默认值为false），主要用于附加组件的代码和浏览器本身。

### **如何实现深拷贝？**

- JSON.stringify()

    -

        - ● JSON.parse(JSON.stringify(obj))是目前比较常用的深拷贝方法之一，它的原理就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象。
        - ● 这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过JSON.stringify()进行处理之后，都会消失。

- 函数库lodash的_.cloneDeep方法

    -

- 手写实现深拷贝函数

    -

## **4.原型**

### **对原型、原型链的理解**

-

    - 在JavaScript中是使用构造函数来初始化一个对象的，每一个构造函数的内部都有一个 prototype（原型对象） 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来访问这个属性（prototype原型对象），但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype（除null外）

### **原型修改、重写**

- 修改：并没有改变构造函数原型对象内部的constructor指向，只是在原型对象身上新增了属性或者方法

    -

- 重写：将构造函数的原型对象直接进行替换，修改了构造函数内部constructor的指向，若想仍然指向原来的构造函数，需要在修改的原型对象内部重新将constructor指向该构造函数

    -
    -

### **原型链指向**

-

### **原型链的终点是什么？如何打印出原型链的终点？**

- 原型链的终点

    - 由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null

- 如何打印出原型链的终点

    - 原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__

        -

### **如何获得对象非原型链上的属性？**

- 使用hasOwnProperty()方法来判断属性是否属于原型链的属性

    -

## **5.异步编程**

### **Event Loop（JS执行机制）**

- JS是单线程，也就是说，同一时间只能做一件事。

    - 同步（按顺序来）

        - 同步任务：同步任务都在主流程上执行，形成一个执行栈。（宏任务）

    - 异步（同时进行）

        - 异步任务：JS的异步是通过回调函数实现的。异步任务相关回调函数添加到任务队列中（任务队列也称消息队列）。一般而言，异步任务有三种类型：

            - 普通事件，如click、resize等
            - 资源加载，如load、error等
            - 定时器，包括setTimeout、setInterval等。

- JS执行机制--Event Loop

    - 先执行执行栈中的同步任务；
    - 异步任务（回调函数）放入任务队列中；
    - 一旦执行栈中的所有同步任务执行完毕，系统会按次序取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
    -
    -

### **什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？**

- 回调函数概念

    - 回调函数是一个作为变量传递给另一个函数的函数，它在主体函数执行完之后再执行

- 回调函数特点

    - 你定义的
    - 你没有调用
    - 但是最终执行了

- 缺点

    - 回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）

        - 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
        - 嵌套函数一多，就很难处理错误

    - 不能使用 try catch 捕获错误
    - 不能直接 return

- 常见的回调函数

    - DOM事件回调函数
    - 定时器回调函数
    - ajax请求回调函数
    - 生命周期回调函数

- 如何解决回调函数

    - promise
    - async/await
    - generator

### **异步编程的实现方式？**

- 回调函数的方式

    - 使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护

- Promise的方式

    - 使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确

- generator的方式

    - 它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行

- async函数的方式

    - async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行

### **对Promise的理解**

- Promise本身是同步的立即执行函数，当在executor中执行resolve（）或者reject（）的时候, 此时是异步操作，也就是说promise中函数体内部的非异步操作正常顺序执行，resolve（）和reject（）异步操作为promise实例对象的返回结果，这个返回结果后面的then或者catch需要用，所以then和catch要放到异步任务中等待所有同步任务执行完毕之后再按顺序（或者如果有定时器，需要遵循定时器的时间）执行。

    -
    -

- Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理
- Promise解决了什么问题/为什么需要promise

    - 在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码

        - 上面的代码有如下缺点：
          ● 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
          ● 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。
        - promise写法：解决了地狱回调的问题

- Promise的实例有三个状态

    - Pending（进行中）
    - Resolved（已完成）
    - Rejected（已拒绝）

- Promise的实例有两个过程

    - pending -> fulfilled : Resolved（已完成）
    - pending -> rejected：Rejected（已拒绝）

- Promise的特点

    - 对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”
    - 一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的

- Promise的缺点

    - 无法取消Promise，一旦新建它就会立即执行，无法中途取消
    - 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部
    - 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）

- 总结

    - Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行

### **Promise解决了什么问题**

- 在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求

    - 上面的代码有如下缺点：
      ● 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
      ● 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观
    - promise形式：代码看起了就简洁了很多，解决了地狱回调的问题

### **Promise的基本用法**

- 创建Promise对象

    - new Promise()法

        -

    - promise.resolve（）方法

        - resolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；

    - promise.reject（）方法

        - reject(‘wrong’)代码中，会让promise对象进入拒绝(reject状态)，并将参数wrong传递给后面的catch所指定的reject 函数；

- Promise方法

    - then（）方法

        - p.then(res => {...},err => {...})

            - then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略
            - then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法

    - catch（）方法

        - p.catch(err => {...})

            - 该方法相当于then方法的第二个参数，指向reject的回调函数

                -

    - all（）方法

        - Promise.all([p1,p2...])

            - all方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected
            - 当所有的子Promise都完成，该Promise完成，返回值是全部值的数组,这个数组按顺序保存着每一个promise对象resolve执行时的值

                -

            - 如果有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果

    - race（）方法

        - Promise.race([p1,p2...])

            - race方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected

                -

            - 实际应用

                - 当要做一件事，超过多长时间就不做了，可以用这个方法来解决

                    -

    - finally（）方法

        - p.finally（）

            - finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作
            - 不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数
            - 服务器使用 Promise 处理请求，然后使用finally方法关掉服务器，finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected

### **Promise.all和Promise.race的区别的使用场景**

- Promise.all（）

    - Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。

- Promise.race（）

    - Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决

        -

### **对async/await 的理解**

- async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。
- async函数返回的是一个Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象，async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象

    - async函数返回的是一个promise对象
    - 可以用then（）方法或者catch（）方法来处理async函数（promise对象）

- 对promise/then、async/await 的理解

    - async函数实际上就是promise对象，promise是同步的立即执行函数，所以aysnc函数也是立即执行函数，也就是说含有async或者promise（下面还有普通函数，或者console.log（...))会按照代码的顺序进行执行（若async函数中有await需要重新考虑执行顺序，具体看下面的tip）

        -

    - promise（async函数）异步任务只针对promise（async函数）中调用的then（）方法或者catch（）方法等里面的函数执行，promise（async函数）中的同步任务正常执行，不会阻塞，此时then或者catch方法里面的代码会放到异步任务队列中，待页面所有同步任务完成后再按照顺序（或时间顺序）执行

        -

    - 没有await的async函数也是立即执行函数，会正常执行async函数里面的代码
    - tip：有await的async函数，会暂时阻碍await下面所有代码的执行，在async函数中并且在await前面的代码（以及await紧跟着的那个异步函数也会正常运行）会正常运行，待await等待到他后面异步函数的结果之后，再执行await下面的代码。注意：await在没有等待到它后面的异步函数的结果时只是阻碍async函数中且在await下面的代码的执行，async函数中且在await前面、await后面紧跟着的那个异步任务的代码，以及async函数之后的代码不会受到影响，会正常运行

        -

### **await 到底在等啥？**

-  await后面必须是异步函数， await是在等待一个异步函数完成，而这个异步函数返回值可能时promise对象，也可能是其他值，而await 等待的就是就是异步函数的返回值

    - 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西
    - 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞在async函数之中且await后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果

### **async/await的优势**

- Promise 通过 then 链来解决多层回调的问题，而 async/await 来进一步优化promise的then（）方法的多层调用
- async/await对比Promise/then（）的优势

    - 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
    - Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅
    - 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余
    - 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步

### **async/await 如何捕获异常**

- try...catch

    - a为await等待的结果，await下面的代码捕获a resolve的信息
    - catch捕获a reject的信息

### **setTimeout、Promise、Async/Await 的区别**

- setTimeout

    - 定时器是异步任务，会将定时器中的代码放到异步任务中，待页面中所有同步任务执行完毕之后再执行异步任务队列

- Promise

    - Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作，会先执行promise中的同步任务，然后执行promise之外的同步操作（按照书写代码的先后顺序），而promise.then( )视为异步任务的方法，会加入到任务队列中，等待全部同步任务执行完毕再按顺序执行异步任务队列中的任务，promise后面的定时器也是异步函数，也要加入到异步函数队列中，即使定时器是0s，而且按照代码书写先后顺序，在任务队列中会排到then后面

- async/await

    - async函数为异步函数，返回的也是promise对象，所以说async函数也是立即执行函数，他里面的代码会按照顺序相继执行；但当有异步任务，且异步任务前面有await时，这时await若未等到异步任务的结果，会阻碍async里面且在await下面的代码（await后面紧跟着的异步任务会正常执行），执行async函数下面的代码直至await等到结果之后再执行它下面在async函数中的代码

### **并发与并行的区别？**

- 并发

    - 并发是宏观概念，在一段时间内通过任务间的切换完成了这些任务，这种情况就可以称之为并发（指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行）

        -

- 并行

    - 并行是微观概念，指在同一时刻，有多条指令在多个处理器上同时执行。同时完成多个任务的情况就可以称之为并行

        -

### **setTimeout、setInterval、requestAnimationFrame 各有什么特点？**

- 异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。

    - 最常用的是setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行，其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，可以通过代码去修正 setTimeout，从而使定时器相对准确
    - setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数，通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题
    - 如果有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现，首先 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题

## **6.执行上下文/作用域链/闭包**

### **对闭包的理解**

- 概念

    - 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
    - 比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

        - 注意：必须要先调用A，B才可以访问到A里面的变量

- 用途

    - 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
    - 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

- 经典面试题：循环中使用闭包解决 var 定义函数的问题

    - 首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法

        - 第一种是使用闭包的方式+立即执行函数

            - 在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的

        - 使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入

            -

        - 第三种就是使用 let 定义 i 了来解决问题

            -

### **对作用域、作用域链的理解**

- 作用域

    - 全局作用域

        - 最外层函数和最外层函数外面定义的变量拥有全局作用域（函数本身也是一个特殊的变量，其名字就是函数名字）
        - 所有未定义直接赋值的变量自动声明为全局作用域
        - 所有window对象的属性拥有全局作用域

    - 局部作用域

        - 声明在函数内部的变量，一般只有固定的代码片段可以访问到
        - 作用域是分层的，内层作用域可以访问外层作用域，反之不行

    - 块级作用域

        - 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）
        - let和const声明的变量不会有变量提升，也不可以重复声明
        - 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部

- 作用域链

    - 概念

        - 在当前作用域中查找所需变量，如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

    - 作用

        - 保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

    - 本质

        - 一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象

### **对执行上下文的理解**

在执行JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数

● 全局上下文：变量定义，函数声明

● 函数上下文：变量定义，函数声明，this，arguments

- 执行上下文类型

    - 全局执行上下文

        - 任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文

    - 函数执行上下文

        - 当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个

    - eval函数执行上下文

        - 执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用

- 执行上下文栈

    - JavaScript引擎使用执行上下文栈来管理执行上下文
    - 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文

        - 输出顺序Inside first function--Inside second function--Again inside first function

## **7.this/call/apply/bind**

### **对this对象的理解**

- apply 、 call 和 bind 调用模式，这三个方法都可以改变指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

### **call() 和 apply() 的区别**

- 它们的作用一模一样，区别仅在于传入参数的形式的不同。
  ● apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。
  ● call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。

## **8.面向对象**

### **如何理解面向对象？**

- 面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，对象是类的实例化。面向对象有三个特点：

    - 封装性

        - 将描述每一个对象的属性以及其行为的程序代码组装到一起，一并封装在一个有机的实体中，把它们封装在一个“模块”中，也就是一个类中

    - 继承性

        - 继承性是面向对象技术中的另外一个重要特点，继承在面向对象技术是指一个对象针对于另一个对象的某些独有的特点、能力进行复制或者延续。

    - 多态性

        - 从宏观的角度来讲，多态性是指在面向对象技术中，当不同的多个对象同时接收到同一个完全相同的消息之后，所表现出来的动作是各不相同的，具有多种形态；从微观的角度来讲，多态性是指在一组对象的一个类中，面向对象技术可以使用相同的调用方式来对相同的函数名进行调用

### **对象创建的方式有哪些？**

- new Object（）方式

    -

- 字面量方式

    -

- 工厂模式

    -

        - 工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系

- 构造函数方式

    -

        - js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个空对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，给实例对象添加属性和方法，最后再指回这个新对象。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的

- 原型方式

    -

        - 因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

- 构造函数+原型方式

    -

        - 这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好

- 类方式

    -

### **对象继承的方式有哪些？**

- 构造函数继承（call/apply）

    -

- prototype原型链继承

    - 子类原型 = 父类实例

        -

- 类继承（extends+super）

    -

## **9.垃圾回收与内存泄露**

### **浏览器的垃圾回收机制**

- 垃圾回收的概念

    - 垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

- 回收机制

    - Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
    - JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
    - 当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

- 垃圾回收的方式

    - 标记清除

        - 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
        - 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

    - 引用计数

        - 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来
        - 这种方法会引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用

            -

- 减少垃圾回收

    - 对数组进行优化

        - 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的

    - 对object进行优化

        - 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收

    - 对函数进行优化

        - 在循环中的函数表达式，如果可以复用，尽量放在函数的外面

### **哪些情况会导致内存泄漏**

- 意外的全局变量

    - 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收

- 被遗忘的计时器或回调函数

    - 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收

- 脱离 DOM 的引用

    - 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收

- 闭包

    - 不合理的使用闭包，从而导致某些变量一直被留在内存当中

