# Vue 面试题

## 开发流程

1. 书写静态页面（HTML + CSS）
2. 拆分组件
3. 获取服务器的数据动态展示
4. 完成相应的动态业务逻辑

## 1.脚手架目录：public + assets文件夹区别

**public**文件夹：一般放置一些共用的静态资源，打包上线的时候，public文件夹里面资源原封不动打包到dist文件夹里面

**assets**文件夹：经常放置一些静态资源（图片），assets文件夹里面资源webpack会进行打包为一个模块（js文件夹里面）

## 2.路由组件和非路由组件的区别？

1. 路由组件一般放在`pages/views`文件夹，非路由组件放在`components`文件夹
2. 路由组件一般需要在`router`文件夹中进行注册，非路由组件一般都是以标签的形式使用
3. 注册完路由，不管是路由组件还是非路由组件，身上都有`$route`和`$router`属性

## 3.$route和$router有什么区别？

`$route`：获取路由信息（路径，query，params）

`$router`：一般进行编程式导航进行路由跳转（push/replace）

## 4.路由跳转

### 路由跳转的方式？

声明式导航`router-link`：可以进行路由的跳转，务必要有`to`属性

编程式导航`push/replace`，可以进行路由跳转。`this.$router.push('/search')`

声明式导航能做的，编程式导航都能做，但是编程式导航除了可以进行路由跳转，还可以做一些其他的业务逻辑

### push和replace有什么区别？

push可以回退，replace替换（不可以回退）

### 编程式路由跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated的警告错误，如何解决

声明式导航没有这类问题，因为`vue-router`底层已经处理好了

为什么编程式导航会有这种错误警告？

`"vue-router": "^3.5.3"`，最新的`vue-router`引入了`Promise`。

方法一：传入成功的回调函数参数

`this.$router.push(location, () => {})`

方法二：catch处理错误的promise

`this.$router.push(location).catch(() => {})`

> 但是上面种方法治标不治本，在别的组件中`push/replace`，编程式导航还是有类似错误。

方法三：重写push/replace方法

```javascript
// 先把VueRouter原型对象的push/replace方法保存一份
const originPush = VueRouter.prototype.push
const originReplace = VueRouter.prototype.replace
// 重写push/replace
// 第一个参数：告诉原来的push方法，你往哪里跳转（传递哪些参数）
VueRouter.prototype.push = function (location, resolve, reject) {
    if (resolve || reject) { // 如果指定了成功或失败的回调
        originPush.call(this, location, resolve, reject) // 直接调用原来的push方法
    } else {
        originPush.call(this, location, () => {}, () => {})
    }
}
VueRouter.prototype.replace = function (location, resolve, reject) {
    if (resolve || reject) { // 如果指定了成功或失败的回调
        originReplace.call(this, location, resolve, reject) // 直接调用原来的replace方法
    } else {
        originReplace.call(this, location, () => {}, () => {})
    }
}
```


## 5.路由传参

### 路由传参的方式？

第一种：字符串拼接

```javascript
this.$router.push('/search/' + this.keyword + '?k=' + this.keyword)
```

第二种：模板字符串

```javascript
this.$router.push(`/search/${this.keyword}?k=${this.keyword}`)
```

**第三种：对象写法**

```javascript
this.$router.push({
  name: 'search',
  params: {keyword: this.keyword || undefined},
  query: {k: this.keyword.toUpperCase()}
})
```

### 路由传参（对象写法）path是否可以结合params参数一起使用？

路由跳转传参的时候，对象的写法，可以是`name/path`，`name`和`path`一起写可以正常使用，但是只有`path`不能与`params`参数一起使用，

### 如何指定params参数可传可不传？

如果路由要求传递`params`参数，但是没有传递，url会有问题。

占位符后面加`?`：`path: '/search/:keyword?'`。代表`params`参数可传可不传

### params参数可传可不传，但是如果传递的是空串，如何解决？

使用`undefined`解决：`params: {keyword: this.keyword || undefined},`

### 路由组件能不能传递props数据？

可以的，有三种写法，在路由配置里写

- 如果 `props` 被设置为 `true`，`route.params` 将会被设置为组件属性。只能传递`params`参数

- 如果 `props` 是一个对象，它会被按原样设置为组件属性。当 `props` 是静态的时候有用。额外给路由组件传递一些props。

- 函数写法：可以将`params`参数，`query`参数，通过`props`传递给路由组件。

   `props: route => ({keyword: route.params.keyword, k: route.query.k})`


## 6.vue中的key有什么作用？（key的内部原理）

1. 虚拟DOM中key的作用：

    - key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】

    - 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2. 对比规则：

    1. 旧虚拟DOM中找到了与新虚拟DOM相同的key：

        - 若虚拟DOM中内容没变, 直接使用之前的真实DOM！

        - 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。

    2. 旧虚拟DOM中未找到与新虚拟DOM相同的key

        - 创建新的真实DOM，随后渲染到到页面。

3. 用index作为key可能会引发的问题：

    1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。

    2. 如果结构中还包含输入类的DOM：会产生错误DOM更新 ==> 界面有问题。

4. 开发中如何选择key?:

    1. 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。

    2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。


## VUE面试

## **1.VUE基础**

### **对vue设计原则的理解**

- 渐进式JavaScript框架

    - 与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应用提供驱动

- 易用性

    - vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。

- 灵活性

    - 渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。

- 高效性

    - 超快的虚拟DOM和diﬀ算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。

### **vue的基本原理**

- 当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将每一个属性身上绑定一个 getter和setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。

    -

### **双向数据绑定的原理**

-

    - Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤

        - M（model--data）

            - 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化

        - V（view）

            - compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

        - VM（vue）

            - Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退

        - MVVM

            - MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果

### ** 使用 Object.defineProperty() 来进行数据劫持有什么缺点？**

- 在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。
- 在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。

### **MVVM、MVC、MVP的区别**

- MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。

    - MVVM

        - **VM作为更新桥梁**

            - MVVM构成

                - Model代表数据模型，数据和业务逻辑都在Model层中定义
                - View代表UI视图，负责数据的展示
                - ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作

            - Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步，这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM

    - MVC

        - **M驱动V（数据驱动视图）**

            - MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新

    - MVP

        - MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑

### **MVVM的优缺点? **

- 优点

    - 分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性
    - 提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码
    - ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放

- 缺点

    - Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的
    - ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，但是当⻓期持有，不释放内存就造成了花费更多的内存
    - 对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼

### **Computed 和 Watch 的区别**

- Computed

    - 它支持缓存，只有依赖的数据发生了变化，才会重新计算
    - 不支持异步，当Computed中有异步操作时，无法监听数据的变化
    - computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的
    - 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
    - 如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法

- Watch

    - 它不支持缓存，数据变化时，它就会触发相应的操作
    - 支持异步监听
    - 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
    - 当一个属性发生变化时，就需要执行相应的操作
    - 监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数

        -   immediate：组件加载立即触发回调函数
        -   deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化

- 总结

    - ● computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。
      ● watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。
    - 运用场景

        - ● 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。
        - ● 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

### **Computed 和 Methods 的区别**

- computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；
- method 调用总会执行该函数

### **对Vue组件化的理解**

- 组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；
- 组件化开发能大幅提高应用开发效率、测试性、复用性等；
- 遵循单向数据流的原则。

### **slot是什么？有什么作用？原理是什么？**

- 概念及作用

    - slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽

        - 默认插槽

            - 又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽

        - 具名插槽

            - 带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽

        - 作用域插槽

            - 默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽

- 原理

    - 当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽

### **过滤器的作用，如何实现一个过滤器**

- 作用

    - 根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。

- 使用场景

    - ● 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。
    - ● 比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。

- 实现过滤器

    - 过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 {{ }} 和 v-bind 表达式 中，然后放在操作符“ | ”后面进行指示。

        -

### **对keep-alive的理解**

- keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM；设置了 keep-alive 缓存的组件，会多出两个生命周期钩子activated 和deactivated

### **如何保存页面的当前的状态**

- 应用场景

    - 项目中常常会有许多列表页，当我们点击进详情后再返回列表页,页面会刷新,导致列表返回到第一条,用户体验并不是很好.这时候我们就需要用到状态保持,让页面保持之前的状态,当用户返回的时候不刷新页面

- 既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况

    - 前组件会被卸载

        - 将状态存储在LocalStorage / SessionStorage

            - 只需要在组件即将被销毁的生命周期中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机

              比如从 B 组件跳转到 A 组件的时候，A 组件需要根据B组件更新自身的状态。但是如果从别的组件跳转到 A 组件的时候，实际上是希望 A组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态

                - 优点

                    - ● 兼容性好，不需要额外库或工具。
                    - ● 简单快捷，基本可以满足大部分需求

                - 缺点

                    - ● 状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）
                    - ● 如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象

        - 路由传值

            - 通过 vue-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。

                - 优点

                    - ● 简单快捷，不会污染 LocalStorage / SessionStorage。
                    - ● 可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）

                - 缺点

                    - 如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑

    - 前组件不会被卸载

        - 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态

            - 优点

                - ● 代码量少
                - ● 不需要考虑状态传递过程中的错误

            - 缺点

                - ● 增加 A 组件维护成本
                - ● 需要传入额外的 prop 到 B 组件
                - ● 无法利用路由定位页面

        - 用keep-alive来缓存页面

            - 在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行，被包裹在keep-alive中的组件的状态将会被保留

                -
                -

### **常见的事件修饰符及其作用**

- ● .stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；
- ● .prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；
- ● .capture ：与事件冒泡的方向相反，事件捕获由外到内；
- ● .self ：只会触发自己范围内的事件，不包含子元素；
- ● .once ：只会触发一次。
- ● .passive：事件的默认行为立即执行，无需等待事件回调执行完毕。

### **v-if、v-show、v-html 的原理**

- ● v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染，v-if指令会根据表达式重建或销毁元素、组件以及它们所绑定的事件；
- ●  v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display，v-show 指令只是简单地设置 css 属性；
- ● v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。

### **v-if和v-show的区别**

- 手段

    - v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐

- 编译过程

    - v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换

- 编译条件

    - v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留

- 性能消耗

    - v-if有更高的切换消耗；v-show有更高的初始渲染消耗

- 使用场景

    - v-if适合不大可能改变；v-show适合频繁切换

### **v-if和v-for哪个优先级更高？如果同时出现，应如何优化？**

- vue2.0版本中v-for优先于v-if被解析，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能。要避免出现这种情况，则在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项
- 3.x 版本中 v-if 总是优先于 v-for 生效

### **v-model的实现原理**

- vue中v-model可以实现数据的双向绑定，但是为什么这个指令就可以实现数据的双向绑定呢？其实v-model是vue的一个语法糖。即利用v-model绑定数据后，既绑定了数据，又添加了一个input事件监听。

    - 实现原理

        - ● v-bind绑定响应数据

            -

        - ● 触发input事件并传递数据

### **v-model 是如何实现的，语法糖实际是什么？**

- 作用在表单元素上

    - 动态绑定了 input 的 value 指向了 message 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：

        -

- 作用在组件上

    - 在父组件中，v-model =“message”默认会将message传递给子组件，子组件用props：["message"]接收，并为自身绑定一个input事件，这个input事件会接收子组件传过来的值，进而修改自己的message的值；在子组件内，用props：["message"]接收父组件传递过来的值，利用事件来触发父组件的事件，并将改变的值传递给父组件

        -
        - **父组件内**
        - **子组件内**

### **v-model 可以被用在自定义组件上吗？如果可以，如何使用？**

- 父组件

    -

        - **相当于**

            - 父组件将searchText变量传入custom-input 组件，使用的 prop 名为value
            - custom-input 组件向父组件传出名为input的事件，父组件将接收到的值赋值给searchText

- 子组件

    -

### **data为什么是一个函数而不是对象**

- Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况

### **$nextTick 原理及作用**

- 原理

    - Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。nextTick 的本质是为了利用 JavaScript 的异步回调任务队列来实现 Vue 框架中自己的异步回调队列。

- 作用

    - Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中

        -

    - 在以下情况下，会用到nextTick

        - ● 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。
        - ● 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。

### **Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？**

-

    - 问题

        - 点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新

    - 原因

        - 这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，也就是没有为该属性设置getter和setter，自然就不会触发视图的更新

    - 解决方法

        - 使用Vue的全局 api $set()，$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了

            -

### **Vue中封装的数组方法有哪些，其如何实现页面更新**

在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化

- Vue中封装的数组方法

    -

- 如何实现页面更新

    - 简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ == arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。

### **vue如何监听对象或者数组某个属性的变化**

- 先判断属性是否原本就存在，若存在，则利用自身的setter和getter实现数据的实时更新
- 当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。

    - 解决方式

        - 数组

            - this.$set(你要改变的数组，你要改变的位置，你要改成什么value)
            - vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。

        - 对象

            - this.$set(你要改变的对象，你要改变的key，你要改成什么value)

        - vm.$set 的实现原理

            - ● 如果目标是数组，直接使用数组的 splice 方法触发响应式；
            - ● 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）

### **Vue 单页应用与多页应用的区别**

- 概念

    - SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源
    - MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新

- 区别

    -

### **对 SPA 单页面的理解，它的优缺点分别是什么？**

- 概念

    - SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

- 优点

    - ● 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
    - ● 基于上面一点，SPA 相对对服务器压力小；
    - ● 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

- 缺点

    - ● 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
    - ● 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
    - ● SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

### **Vue模版编译原理**

- vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所以需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。

    - 解析阶段

        - 使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST

    - 优化阶段

        - 遍历AST，找到其中的一些静态节点并进行标记，方便在页面重新渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能

    - 生成阶段

        - 将最终的AST转化为render函数字符串，生成render函数，浏览器执行render函数，在页面中渲染出对应的HTML元素

### **Vue template 到 render 的过程                             **

- vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数

    - CompileToFunctions中的主要逻辑如下

        - 调用parse方法将template转化为ast（抽象语法树）

            - ● parse的目标：把template转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。
              ● 解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。
              AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本

        - 对静态节点做优化

            - 这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化，深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用

        - 生成代码

            - generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function( render) 生成render函数

### **对SSR的理解**

- 概念

    - SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端

- 优势

    - ● 更好的SEO
    - ● 首屏加载速度更快

- 劣势

    - ● 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；
    - ● 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；
    - ● 更多的服务端负载。

### **Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？**

- 不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。

### **什么是 mixin ？**

- Mixin 使我们能够为 Vue 组件编写可重用的功能。
- 如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。
- 然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优先于组件自已的 hook。

### **简述 mixin、extends 的覆盖逻辑**

- mixin 和 extends

    - mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并

        - ● mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。
        - ● extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。

- mixin、extends 的覆盖逻辑

    -

- mergeOptions 的执行过程

    - 规范化选项
    - 对未合并的选项，进行判断

        -

    - 合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里
    - 返回合并结果 options

### **mixin 和 mixins 区别**

- mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。虽然文档不建议在应用中直接使用 mixin，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 ajax 或者一些工具函数等等。

    -

- mixins 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行（watch也是），并且在遇到同名选项的时候也会有选择性的进行合并。

    -

### **描述下Vue自定义指令**

- 为什么要使用自定义指令

    - 在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令，一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据

- 自定义指令分类

    - 全局自定义指令

        - **在任意页面的任意位置都可使用的自定义指令**

    - 局部自定义指令

        - **只针定义自定义指令所在的组件内的元素**

- 自定义指令定义方式

    - 函数形式

        -

    - 对象形式

        -  配置对象中常用的3个回调:
           □ bind:指令与元素成功绑定时调用。
           □ inserted:指令所在元素被插入页面时调用。
           □ update:指令所在模板结构被重新解析时调用。

- 钩子函数

    - bind

        - 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。

    - inSerted

        - 被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。

    - update

        - 所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。

    - ComponentUpdate

        - 指令所在组件的 VNode及其子VNode全部更新后调用

    - unbind

        - 只调用一次，指令与元素解绑时调用

- 钩子函数参数

    - el

        - 绑定元素

    - binding

        - 指令核心对象，描述指令全部信息属性

    - name
    - value
    - oldValue
    - expression
    - arg
    - modifers
    - vnode

        - 虚拟节点

    - oldVnode

        - 上一个虚拟节点（更新钩子函数中才有用）

- 使用场景

    - 普通DOM元素进行底层操作的时候，可以使用自定义指令
    - 自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。

- 使用案例

    - 初级应用

        - 鼠标聚焦
        - 下拉菜单
        - 相对时间转换
        - 滚动动画

    - 高级应用

        - 自定义指令实现图片懒加载
        - 自定义指令集成第三方插件

### **子组件可以直接改变父组件的数据吗？**

- 子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

### **Vue是如何收集依赖的？**

- 在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑

### ** Vue的优点**

- 轻量级框架

    - 只关注视图层，是一个构建数据的视图集合，大小只有几十 kb

- 简单易学

    - 国人开发，中文文档，不存在语言障碍 ，易于理解和学习

- 双向数据绑定

    - 保留了 angular 的特点，在数据操作方面更为简单

- 组件化

    - 保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势

- 视图，数据，结构分离

    - 使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作

- 虚拟DOM

    - dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；

- 运行速度更快

    - 相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势

### **assets和static的区别**

- 相同点

    - assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下

- 不同点

    - assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器
    - static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。

- 建议

    -  将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。

### **delete和Vue.delete删除数组的区别**

- delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变，数组长度不变

    -

- Vue.delete 直接删除了数组元素，改变了数组的键值，数组长度变化。

    -

### **Vue的性能优化有哪些**

- 编码阶段

    - ● 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
    - ● v-if和v-for不能连用
    - ● 如果需要使用v-for给每项元素绑定事件时使用事件代理
    - ● SPA 页面采用keep-alive缓存组件
    - ● key保证唯一
    - ● 使用路由懒加载、异步组件
    - ● 防抖、节流
    - ● 第三方模块按需导入
    - ● 长列表滚动到可视区域动态加载
    - ● 图片懒加载

- SEO优化

    - ● 预渲染（渲染到虚拟DOM上）
    - ● 服务端渲染SSR

- 打包优化

    - ● 压缩代码
    - ● Tree Shaking/Scope Hoisting
    - ● 使用cdn加载第三方模块
    - ● 多线程打包happypack
    - ● splitChunks抽离公共文件
    - ● sourceMap优化

- 用户体验

    - ● 骨架屏
    - ● PWA
    - ● 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。

### **常见的Vue性能优化方法**

- 路由懒加载

    -

- keep-alive缓存页面

    -

- 使用v-show复用DOM

    - **两个模块来回切换**

- v-for 遍历避免同时使用 v-if
- 长列表滚动到可视区域动态加载
- 图片懒加载

    - 对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。

- 第三方插件按需引入

    - 像element-ui这样的第三方组件库可以按需引入避免体积太大

- SSR（服务端渲染）
- 变量本地化
- 子组件分隔
- 无状态的组件标记为函数式组件

### **vue初始化页面闪动问题**

- 闪动问题出现原因

    - 使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。

- 解决方案

    - 我们可以使用 v-cloak 指令来解决这一问题。v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除

        -
        -

- 注意

    - 在简单项目中，使用 v-cloak 指令是解决屏幕闪动的好方法。但在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令（大型项目中一般不会出现闪现现象）

## **2.生命周期**

### **说一下Vue的生命周期**

- Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。

    - beforeCreate（创建前）

        - 数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据

    - created（创建后）

        - 实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，可以访问data数据以及methods方法，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性（vm实例身上）。

    - beforeMount（挂载前）

        - 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上，虚拟DOM生成，此时页面渲染的是未经vue编译的DOM结构

    - mounted（挂载后）

        - 在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。

    - beforeUpdate（更新前）

        - 响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。

    - updated（更新后）

        - 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。

    - beforeDestroy（销毁前）

        - 实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。

    - destroyed（销毁后）

        - 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。

    - 另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，缓存渲染后会执行 activated 钩子函数。

### **Vue 子组件和父组件执行顺序**

- 加载渲染过程

    - 1.父组件 beforeCreate
    - 2.父组件 created
    - 3.父组件 beforeMount
    - 4.子组件 beforeCreate
    - 5.子组件 created
    - 6.子组件 beforeMount
    - 7.子组件 mounted
    - 8.父组件 mounted

- 更新过程

    - 1. 父组件 beforeUpdate
    - 2.子组件 beforeUpdate
    - 3.子组件 updated
    - 4.父组件 updated

- 销毁过程

    - 1. 父组件 beforeDestroy
    - 2.子组件 beforeDestroy
    - 3.子组件 destroyed
    - 4.父组件 destoryed

### **created和mounted的区别**

- created

    - 在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图，此时可以访问到data数据及methods中的方法等。

- mounted

    - 在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作（尽量避免），至此初始化过程结束，一般在此阶段会发送ajax请求，开启定时器、绑定自定义事件，订阅消息等初始化操作。

### **一般在哪个生命周期请求异步数据**

- 我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

    - 能更快获取到服务端数据，减少页面加载时间，用户体验更好；
    - SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性

### **keep-alive 中的生命周期哪些**

- keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。

    - 如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。

        - 当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。

## **3.组件通信**

### **常用的组件间通信方式有哪些？**

- 父->子组件通信

    - props

        - **父组件**

            - **子组件**

                - props只能是父组件向子组件进行传值，props使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。
                - props 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。

    - 依赖注入（（provide/ inject））

      这种方式就是Vue中的依赖注入，该方法用于父子组件之间的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。

        - provide / inject是Vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。● provide 钩子用来发送数据或方法● inject钩子用来接收数据或方法

            - **父组件**
            - **子组件**
            - **或者这样写可以访问父组件中的所有属性**

- 子->父组件通信

    - 自定义事件（$emit）

        - **父组件**

            - **子组件**

    - ref/$refs

        - ref： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。

            - **子组件**
            - **父组件**

- 父子组件通信

    - $parent / $children

        - ● 使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）【对象】
          ● 使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序（如果有多个孩子，不要用索引的方式，可以用$refs打标记），并且访问的数据也不是响应式的。【数组】

            -  父组件

                -

                    - ref可以获取到某一个DOM节点、组件标签、子组件标签（以便操作子组件的数据与方法）；$children组件实例的属性，可以获取到当前组件的全部子组件【数组】

            -  子组件

                - $parent组件实例的属性，可以获取到当前子组件的父组件。从而可以操作父组件的数据和方法

- 跨代通信

  考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？



如果是用props/$emit来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。



针对上述情况，Vue引入了$attrs / $listeners，实现组件之间的跨代通信。




- $attrs / $listeners（属性/方法）

    - $attrs：继承所有的父组件属性（除了子组件prop接收的属性），一般用在子组件的子元素上【对象形式】
    - $listeners：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 v-on="$listeners" 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）【对象形式】
    - inheritAttrs

        - inheritAttrs：默认值 true，继承所有的父组件属性（除 props 的特定绑定）作为普通的HTML特性应用在子组件的根元素上，如果你不希望组件的根元素继承特性设置 inheritAttrs: false ,但是 class 属性会继承。

    - 例子

        - 父组件

            -

        - 子组件

            -

        - 孙子组件

            -

        - 效果

            -

        - 注意

            - 孙子组件中能直接触发父组件的自定义方法的原因在于子组件调用孙子组件时 使用 v-on 绑定了$listeners 属性
            - 在子组件中通过v-bind 绑定$attrs属性，孙子组件可以直接获取到父组件中传递下来的props（除了子组件中props声明的）

- 所有组件间通讯

    - 全局事件总线

        - 创建事件中心管理组件之间的通信

            -

        - 发送事件

            - 传递方this.$bus.$emit('xxx',数据）

        - 接收事件

            - 接收方this.$bus.$on('xxx',this.方法名)/this.$bus.$on('xxx',回调函数)【回调函数写成箭头函数】

                -

        - 注意

            -

                -

    - vuex

## **4.vuex**

### **Vuex 的原理**

-

    - vuex概述

        - Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

            - ● Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
            - ● 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。

    - 核心流程及主要功能

        - ● Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;
        - ● 在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;
        - ● 然后 Mutations 就去改变（Mutate）State 中的数据;
        - ● 当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。

    - 各模块在核心流程中的主要功能

        - ● Vue Components∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。
        - ● dispatch∶操作行为触发方法，是唯一能执行action的方法。
        - ● actions∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。
        - ● commit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。
        - ● mutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。
        - ● state∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，并进行状态更新。
        - ● getters∶ state对象读取方法。

    - 总结

        - Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。

### **为什么要用 Vuex**

- 对于多层嵌套的组件之间传递数据采取传参或者组件间通信的方式将会非常繁琐，而且通常会导致代码无法维护。所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的"视图"，不管在树的哪个位置，任何组件都能获取状态或者触发行为。另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。而且vuex中的数据是响应式的，只要vuex中的数据更新，依赖他的数据的组件也会跟着更新。

### **Vuex有哪几种属性？**

- state => 基本数据(数据源存放地)
- getters => 从基本数据派生出来的数据
- mutations => 提交更改数据的方法，同步
- actions => 像一个装饰器，包裹mutations，使之可以异步。
- modules => 模块化Vuex

### ** Vuex中actions和mutations的区别**

- mutations

    - mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。

- actions

    - Action 可以包含任意异步操作，Action 提交的是 mutation，而不是直接变更状态。

- 区别

    - Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。
    - Mutation：必须同步执行；Action：可以异步，但不能直接操作State。
    - 在视图更新时，先触发actions，actions再触发mutations

### **为什么 Vuex 的 mutation 中不能做异步操作？**

- 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以将新的状态存下来，然后就可以实现 数据的更新 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

### **Vuex 和 localStorage 的区别**

- 存储位置区别

    - ● vuex存储在内存中
    - ● localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快

- 应用场景区别

    - ● Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。
    - ● localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。

- 响应式区别

    - Vuex能做到数据的响应式

    - localstorage不能做到数据的响应式

      对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到

- 时效区别

    - 刷新页面时vuex存储的值会丢失
    - 刷新页面时localstorage存储的值不会丢失

### **Vuex和单纯的全局对象有什么区别？**

- Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
- 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。

### **Vuex的严格模式是什么,有什么作用，如何开启？**

- 严格模式作用

    - 在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。

- 开启方式

    -

### **如何在组件中批量使用Vuex的getter属性**

- 使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中

    -

### **如何在组件中重复使用Vuex的mutation**

- **在组件中使用，然后调用this.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)**

## **5.router**

### **对前端路由的理解**

- 路由

    - 路由是url到函数的映射，可以根据不同的url地址展示不同的内容或页面。

- 服务器端路由（后端路由）

    - 对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。

- 客户端路由（前端路由）

    - 早期的路由都是后端实现的，直接根据 url 来 reload 页面，页面变得越来越复杂服务器端压力变大，随着 ajax 的出现，页面实现非 reload 就能刷新数据，更新页面内容，使内容的切换更加流畅，可以通过记录 url 来记录 ajax 的变化，从而实现前端路由。对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。

        - 前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。

### **Vue-router跳转和location.href有什么区别**

- 使用 location.href= ‘/url’ 来跳转，简单方便，但是刷新了页面；
- 引进 router ，然后使用 router.push( ‘/url’ ) 来跳转，无刷新页面，静态跳转。使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。使用 router 跳转底层是用history.pushState()

### **$route 和$router 的区别**

- $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等，可以使用$router.push()、$router.replace()、$router.go()等
- $route 是“路由信息对象”，包括 name，path，params，query，meta，fullPath，hash、matched等路由信息参数

### **params和query的区别**

- 用法

    - query可以用name和path来引入；接收参数this.$route.query.name；在路由信息配置时路径path不需要占位
    - params要用name来引入；接收参数this.$route.params.name；在路由信息配置时路径path需要占位

- url地址显示

    - query更加类似于ajax中get传参，在浏览器地址栏中显示参数
    - params则类似于post，在浏览器地址栏中不显示参数

- 刷新

    - query刷新不会丢失query里面的数据
    - params刷新会丢失 params里面的数据（可考虑采取本地存储解决此问题）

### ** 路由的hash和history模式的区别**

- hash模式

    - 简介

        - hash模式是开发中默认的模式，它的URL带着一个#，例如：http://www.abc.com/#/vue，它的hash值就是#/vue。

    - 特点

        - hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。

    - 原理

        - hash模式的主要原理就是onhashchange()事件：

            - 使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。

- history模式

    - 简介

        - history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。

    - 特点

        - 当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。

    - API

        - history api可以分为两大部分，切换历史状态和修改历史状态：

            - 修改历史状态

                - 包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。

            - 切换历史状态

                - 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。

    - 虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。
    - 切换为history模式

        -

- 调用 history.pushState() 与直接修改 hash对比

    - pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
    - pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
    - pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
    - pushState() 可额外设置 title 属性供后续使用。
    - hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。

### **如何获取页面的hash变化**

- 监听$route的变化

    -

- window.location.hash读取#值

    - window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。

### **如何定义动态路由？如何获取传过来的动态参数？**

- params传参

    - 路由格式

        - 配置路由格式：/router/:id
        - 传递的方式：在path后面跟上对应的值
        - 传递后形成的路径：/router/123

    - 定义路由

        -

    - 接收参数

        - 通过 $route.params.userid 获取传递的值

- query传参

    - 路由格式

        - 配置路由格式：/router？key1=value1&key2=value2
        - 传递的方式：对象中使用query的key作为传递方式
        - 传递后形成的路径：/route?id=123&uname=cara

    - 定义路由

        -

    - 接收参数

        - 通过$route.query.userid获取传递的值

### **Vue-Router 的懒加载如何实现**

- 非懒加载

    -

- 懒加载

    - 使用箭头函数+import动态加载

        -

    - 使用箭头函数+require动态加载

        -

    - webpack

      使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。

        -

### **Vue-router 导航守卫有哪些**

- 全局守卫（前置/后置）：beforeEach、beforeResolve、afterEach
- 路由独享的守卫：beforeEnter
- 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave

### **Vue-router 路由守卫在生命周期的体现**

- 完整的路由导航解析流程

    - ● 触发进入其他路由。
    - ● 调用要离开路由的组件守卫beforeRouteLeave
    - ● 调用全局前置守卫∶ beforeEach
    - ● 在重用的组件里调用 beforeRouteUpdate
    - ● 调用路由独享守卫 beforeEnter。
    - ● 解析异步路由组件。
    - ● 在将要进入的路由组件中调用 beforeRouteEnter
    - ● 调用全局解析守卫 beforeResolve
    - ● 导航被确认。
    - ● 调用全局后置钩子的 afterEach 钩子。
    - ● 触发DOM更新（mounted）。
    - ● 执行beforeRouteEnter 守卫中传给 next 的回调函数

- 触发钩子的完整顺序

    - ● beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。
    - ● beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。
    - ● beforeEnter：路由独享守卫
    - ● beforeRouteEnter：路由组件的组件进入路由前钩子。
    - ● beforeResolve：路由全局解析守卫
    - ● afterEach：路由全局后置钩子
    - ● beforeCreate：组件生命周期，不能访问this。
    - ● created;组件生命周期，可以访问this，不能访问dom。
    - ● beforeMount：组件生命周期
    - ● deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。
    - ● mounted：访问/操作dom。
    - ● activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。
    - ● 执行beforeRouteEnter回调函数next。

- 导航行为被触发到导航完成的整个过程

    - ● 导航行为被触发，此时导航未被确认。
    - ● 在失活的组件里调用离开守卫 beforeRouteLeave。
    - ● 调用全局的 beforeEach守卫。
    - ● 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。
    - ● 在路由配置里调用 beforeEnteY。
    - ● 解析异步路由组件（如果有）。
    - ● 在被激活的组件里调用 beforeRouteEnter。
    - ● 调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。
    - ● 导航被确认。
    - ● 调用全局的 afterEach 钩子。
    - ● 非重用组件，开始组件实例的生命周期：beforeCreate&created、beforeMount&mounted
    - ● 触发 DOM 更新。
    - ● 用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。
    - ● 导航完成

## **6.vue3.0**

### **Vue3.0有什么更新**

- 监测机制的改变

    - ● 3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。
    - ● 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制

        - 检测属性的添加和删除；
        - 检测数组索引和长度的变更；
        - 支持 Map、Set、WeakMap 和 WeakSet。

- 模板

    - ● 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。
    - ● 同时，对于 render 函数的方面，vue3.0 也进行一系列更改来方便习惯直接使用 api 来生成 vdom 。

- 对象式的组件声明方式

    - ● vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。
    - ● 3.0 修改了组件的声明方式，这样使得和 TypeScript 的结合变得很容易

- 其它方面的更改

    - ● 支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。
    - ● 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。
    - ● 基于 tree shaking 优化，提供了更多的内置功能。

### **defineProperty和proxy的区别**

- defineProperty

    - Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。
    - 存在的问题

        - 1. 添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。
        - 2. 无法监控到数组下标和长度的变化。

- proxy

    - Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）

- defineProperty和proxy的区别

    - 1. Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。
    - 2. Proxy 可以监听数组的变化。

### **Vue3.0 为什么要用 proxy？**

- 在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶

    - ● 不需用使用 Vue.$set 或 Vue.$delete 触发响应式。
    - ● 全方位的数组变化检测，消除了Vue2 无效的边界情况。
    - ● 支持 Map，Set，WeakMap 和 WeakSet。

- Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶

    - ● get 收集依赖
    - ● set、delete 等触发依赖
    - ● 对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。

### ** Vue 3.0 中的 Vue Composition API？**

- 在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。造成了几个问题：

    - 1. 由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。
    - 2. Vue 组件过于依赖this上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 TypeScript 在Vue2 中很不好用。

- Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。

    - **Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性**

## **7.虚拟DOM**

### **对虚拟DOM的理解？**

- 虚拟DOM就是用来描述真实DOM的javaScript对象，可以将多次修改的DOM一次性渲染到页面上，减少页面的重排重绘，提高渲染性能。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。

### **虚拟DOM的解析过程**

- ● 首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来并将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。
- ● 当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。
- ● 最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。

### **为什么要用虚拟DOM**

- 保证性能下限，在不进行手动优化的情况下，提供过得去的性能

    - 页面渲染的流程

        - 解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler

    - 对比修改DOM时真实DOM操作和虚拟DOM的过程

        - 真实DOM∶ 生成HTML字符串＋重建所有的DOM元素
        - 虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新

- 跨平台

    - Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。

### **虚拟DOM真的比真实DOM性能好吗**

- 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。
- 正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。

### **DIFF算法的原理**

- ● 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
- ● 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的没有子节点，将旧的子节点移除)
- ● 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。
- ● 匹配时，找到相同的子节点，递归比较子节点
- ● 更新差异，复用节点

### **Vue中key的作用**

- 第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。
- 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。
- 总结

    - vue为了更高效的渲染元素，会尽可能的复用元素，而非从头渲染，key可以为节点打标记，而非简单的复用节点。当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则

        - 旧虚拟DOM中找到了与新虚拟DOM相同的key

            - 若虚拟DOM中内容没变, 直接使用之前的真实DOM
            - 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM

        - 旧虚拟DOM中未找到与新虚拟DOM相同的key

            - 创建新的真实DOM，随后渲染到到页面

### **为什么不建议用index作为key?**

- 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低
- 如果逆序添加、逆序删除等破坏顺序的操作且结构中还包含输入类的DOM：会产生错误DOM更新 ==> 界面有问题

