# JavaScript 面试


## **4.原型**

### **对原型、原型链的理解**

-

    - 在JavaScript中是使用构造函数来初始化一个对象的，每一个构造函数的内部都有一个 prototype（原型对象）
      属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5
      中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来访问这个属性（prototype原型对象），但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个
      Object.getPrototypeOf()
      方法，可以通过这个方法来获取对象的原型。当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是
      Object.prototype（除null外）

### **原型修改、重写**

- 修改：并没有改变构造函数原型对象内部的constructor指向，只是在原型对象身上新增了属性或者方法

    -

- 重写：将构造函数的原型对象直接进行替换，修改了构造函数内部constructor的指向，若想仍然指向原来的构造函数，需要在修改的原型对象内部重新将constructor指向该构造函数

    -
    -

### **原型链指向**

-

### **原型链的终点是什么？如何打印出原型链的终点？**

- 原型链的终点

    - 由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null

- 如何打印出原型链的终点

    - 原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__

        -

### **如何获得对象非原型链上的属性？**

- 使用hasOwnProperty()方法来判断属性是否属于原型链的属性

    -

## **5.异步编程**

### **Event Loop（JS执行机制）**

- JS是单线程，也就是说，同一时间只能做一件事。

    - 同步（按顺序来）

        - 同步任务：同步任务都在主流程上执行，形成一个执行栈。（宏任务）

    - 异步（同时进行）

        - 异步任务：JS的异步是通过回调函数实现的。异步任务相关回调函数添加到任务队列中（任务队列也称消息队列）。一般而言，异步任务有三种类型：

            - 普通事件，如click、resize等
            - 资源加载，如load、error等
            - 定时器，包括setTimeout、setInterval等。

- JS执行机制--Event Loop

    - 先执行执行栈中的同步任务；
    - 异步任务（回调函数）放入任务队列中；
    - 一旦执行栈中的所有同步任务执行完毕，系统会按次序取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
    -
    -

### **什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？**

- 回调函数概念

    - 回调函数是一个作为变量传递给另一个函数的函数，它在主体函数执行完之后再执行

- 回调函数特点

    - 你定义的
    - 你没有调用
    - 但是最终执行了

- 缺点

    - 回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）

        - 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
        - 嵌套函数一多，就很难处理错误

    - 不能使用 try catch 捕获错误
    - 不能直接 return

- 常见的回调函数

    - DOM事件回调函数
    - 定时器回调函数
    - ajax请求回调函数
    - 生命周期回调函数

- 如何解决回调函数

    - promise
    - async/await
    - generator

### **异步编程的实现方式？**

- 回调函数的方式

    - 使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护

- Promise的方式

    - 使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确

- generator的方式

    - 它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator
      内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行

- async函数的方式

    - async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise
      对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行

### **对Promise的理解**

- Promise本身是同步的立即执行函数，当在executor中执行resolve（）或者reject（）的时候,
  此时是异步操作，也就是说promise中函数体内部的非异步操作正常顺序执行，resolve（）和reject（）异步操作为promise实例对象的返回结果，这个返回结果后面的then或者catch需要用，所以then和catch要放到异步任务中等待所有同步任务执行完毕之后再按顺序（或者如果有定时器，需要遵循定时器的时间）执行。

    -
    -

-
Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise
是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理
- Promise解决了什么问题/为什么需要promise

    - 在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码

        - 上面的代码有如下缺点：
          ● 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
          ● 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。
        - promise写法：解决了地狱回调的问题

- Promise的实例有三个状态

    - Pending（进行中）
    - Resolved（已完成）
    - Rejected（已拒绝）

- Promise的实例有两个过程

    - pending -> fulfilled : Resolved（已完成）
    - pending -> rejected：Rejected（已拒绝）

- Promise的特点

    -
    对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”
    -
    一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的

- Promise的缺点

    - 无法取消Promise，一旦新建它就会立即执行，无法中途取消
    - 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部
    - 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）

- 总结

    - Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和
      rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和
      reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then
      方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行

### **Promise解决了什么问题**

- 在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求

    - 上面的代码有如下缺点：
      ● 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。
      ● 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观
    - promise形式：代码看起了就简洁了很多，解决了地狱回调的问题

### **Promise的基本用法**

- 创建Promise对象

    - new Promise()法

        -

    - promise.resolve（）方法

        - resolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；

    - promise.reject（）方法

        - reject(‘wrong’)代码中，会让promise对象进入拒绝(reject状态)，并将参数wrong传递给后面的catch所指定的reject 函数；

- Promise方法

    - then（）方法

        - p.then(res => {...},err => {...})

            - then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略
            - then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法

    - catch（）方法

        - p.catch(err => {...})

            - 该方法相当于then方法的第二个参数，指向reject的回调函数

                -

    - all（）方法

        - Promise.all([p1,p2...])

            - all方法可以完成并行任务，
              它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected
            - 当所有的子Promise都完成，该Promise完成，返回值是全部值的数组,这个数组按顺序保存着每一个promise对象resolve执行时的值

                -

            - 如果有任何一个失败，该Promise失败，返回值是第一个失败的子Promise的结果

    - race（）方法

        - Promise.race([p1,p2...])

            -
            race方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected

                -

            - 实际应用

                - 当要做一件事，超过多长时间就不做了，可以用这个方法来解决

                    -

    - finally（）方法

        - p.finally（）

            - finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作
            - 不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数
            - 服务器使用 Promise 处理请求，然后使用finally方法关掉服务器，finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise
              状态到底是fulfilled还是rejected

### **Promise.all和Promise.race的区别的使用场景**

- Promise.all（）

    -
    Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。

- Promise.race（）

    - Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])
      里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决

        -

### **对async/await 的理解**

- async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个
  function 是异步的，而 await 用于等待一个异步方法执行完成。
- async函数返回的是一个Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象，async 函数返回的是一个 Promise
  对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象

    - async函数返回的是一个promise对象
    - 可以用then（）方法或者catch（）方法来处理async函数（promise对象）

- 对promise/then、async/await 的理解

    - async函数实际上就是promise对象，promise是同步的立即执行函数，所以aysnc函数也是立即执行函数，也就是说含有async或者promise（下面还有普通函数，或者console.log（...))
      会按照代码的顺序进行执行（若async函数中有await需要重新考虑执行顺序，具体看下面的tip）

        -

    -
    promise（async函数）异步任务只针对promise（async函数）中调用的then（）方法或者catch（）方法等里面的函数执行，promise（async函数）中的同步任务正常执行，不会阻塞，此时then或者catch方法里面的代码会放到异步任务队列中，待页面所有同步任务完成后再按照顺序（或时间顺序）执行

        -

    - 没有await的async函数也是立即执行函数，会正常执行async函数里面的代码
    -
    tip：有await的async函数，会暂时阻碍await下面所有代码的执行，在async函数中并且在await前面的代码（以及await紧跟着的那个异步函数也会正常运行）会正常运行，待await等待到他后面异步函数的结果之后，再执行await下面的代码。注意：await在没有等待到它后面的异步函数的结果时只是阻碍async函数中且在await下面的代码的执行，async函数中且在await前面、await后面紧跟着的那个异步任务的代码，以及async函数之后的代码不会受到影响，会正常运行

        -

### **await 到底在等啥？**

- await后面必须是异步函数， await是在等待一个异步函数完成，而这个异步函数返回值可能时promise对象，也可能是其他值，而await 等待的就是就是异步函数的返回值

    - 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西
    - 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞在async函数之中且await后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果

### **async/await的优势**

- Promise 通过 then 链来解决多层回调的问题，而 async/await 来进一步优化promise的then（）方法的多层调用
- async/await对比Promise/then（）的优势

    - 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
    - Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅
    - 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余
    - 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)
      功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步

### **async/await 如何捕获异常**

- try...catch

    - a为await等待的结果，await下面的代码捕获a resolve的信息
    - catch捕获a reject的信息

### **setTimeout、Promise、Async/Await 的区别**

- setTimeout

    - 定时器是异步任务，会将定时器中的代码放到异步任务中，待页面中所有同步任务执行完毕之后再执行异步任务队列

- Promise

    - Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候,
      此时是异步操作，会先执行promise中的同步任务，然后执行promise之外的同步操作（按照书写代码的先后顺序），而promise.then( )
      视为异步任务的方法，会加入到任务队列中，等待全部同步任务执行完毕再按顺序执行异步任务队列中的任务，promise后面的定时器也是异步函数，也要加入到异步函数队列中，即使定时器是0s，而且按照代码书写先后顺序，在任务队列中会排到then后面

- async/await

    -
    async函数为异步函数，返回的也是promise对象，所以说async函数也是立即执行函数，他里面的代码会按照顺序相继执行；但当有异步任务，且异步任务前面有await时，这时await若未等到异步任务的结果，会阻碍async里面且在await下面的代码（await后面紧跟着的异步任务会正常执行），执行async函数下面的代码直至await等到结果之后再执行它下面在async函数中的代码

### **并发与并行的区别？**

- 并发

    - 并发是宏观概念，在一段时间内通过任务间的切换完成了这些任务，这种情况就可以称之为并发（指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行）

        -

- 并行

    - 并行是微观概念，指在同一时刻，有多条指令在多个处理器上同时执行。同时完成多个任务的情况就可以称之为并行

        -

### **setTimeout、setInterval、requestAnimationFrame 各有什么特点？**

- 异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。

    - 最常用的是setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行，其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout
      不会按期执行。当然了，可以通过代码去修正 setTimeout，从而使定时器相对准确
    - setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数，通常来说不建议使用 setInterval。第一，它和 setTimeout
      一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题
    - 如果有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现，首先 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6
      毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题

## **6.执行上下文/作用域链/闭包**

### **对闭包的理解**

- 概念

    - 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
    - 比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

        - 注意：必须要先调用A，B才可以访问到A里面的变量

- 用途

    - 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
    - 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

- 经典面试题：循环中使用闭包解决 var 定义函数的问题

    - 首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法

        - 第一种是使用闭包的方式+立即执行函数

            - 在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的

        - 使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入

            -

        - 第三种就是使用 let 定义 i 了来解决问题

            -

### **对作用域、作用域链的理解**

- 作用域

    - 全局作用域

        - 最外层函数和最外层函数外面定义的变量拥有全局作用域（函数本身也是一个特殊的变量，其名字就是函数名字）
        - 所有未定义直接赋值的变量自动声明为全局作用域
        - 所有window对象的属性拥有全局作用域

    - 局部作用域

        - 声明在函数内部的变量，一般只有固定的代码片段可以访问到
        - 作用域是分层的，内层作用域可以访问外层作用域，反之不行

    - 块级作用域

        - 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）
        - let和const声明的变量不会有变量提升，也不可以重复声明
        - 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部

- 作用域链

    - 概念

        - 在当前作用域中查找所需变量，如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

    - 作用

        - 保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

    - 本质

        - 一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象

### **对执行上下文的理解**

在执行JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数

● 全局上下文：变量定义，函数声明

● 函数上下文：变量定义，函数声明，this，arguments

- 执行上下文类型

    - 全局执行上下文

        - 任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文

    - 函数执行上下文

        - 当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个

    - eval函数执行上下文

        - 执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用

- 执行上下文栈

    - JavaScript引擎使用执行上下文栈来管理执行上下文
    -
    当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文

        - 输出顺序Inside first function--Inside second function--Again inside first function

## **7.this/call/apply/bind**

### **对this对象的理解**

- apply 、 call 和 bind 调用模式，这三个方法都可以改变指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this
  绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用
  new 时会被改变，其他情况下都不会改变。

### **call() 和 apply() 的区别**

- 它们的作用一模一样，区别仅在于传入参数的形式的不同。
  ● apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。
  ● call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。

## **8.面向对象**

### **如何理解面向对象？**

- 面向对象程序设计以对象为核心，该方法认为程序由一系列对象组成。类是对现实世界的抽象，包括表示静态属性的数据和对数据的操作，对象是类的实例化。面向对象有三个特点：

    - 封装性

        - 将描述每一个对象的属性以及其行为的程序代码组装到一起，一并封装在一个有机的实体中，把它们封装在一个“模块”中，也就是一个类中

    - 继承性

        - 继承性是面向对象技术中的另外一个重要特点，继承在面向对象技术是指一个对象针对于另一个对象的某些独有的特点、能力进行复制或者延续。

    - 多态性

        -
        从宏观的角度来讲，多态性是指在面向对象技术中，当不同的多个对象同时接收到同一个完全相同的消息之后，所表现出来的动作是各不相同的，具有多种形态；从微观的角度来讲，多态性是指在一组对象的一个类中，面向对象技术可以使用相同的调用方式来对相同的函数名进行调用

### **对象创建的方式有哪些？**

- new Object（）方式

    -

- 字面量方式

    -

- 工厂模式

    -

        - 工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系

- 构造函数方式

    -

        - js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个空对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的
          this
          指向这个对象，最后再执行整个函数，给实例对象添加属性和方法，最后再指回这个新对象。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在
          js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的

- 原型方式

    -

        - 因为每一个函数都有一个 prototype
          属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如
          Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。

- 构造函数+原型方式

    -

        -
        这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好

- 类方式

    -

### **对象继承的方式有哪些？**

- 构造函数继承（call/apply）

    -

- prototype原型链继承

    - 子类原型 = 父类实例

        -

- 类继承（extends+super）

    -

## **9.垃圾回收与内存泄露**

### **浏览器的垃圾回收机制**

- 垃圾回收的概念

    - 垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

- 回收机制

    - Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
    -
    JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
    - 当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

- 垃圾回收的方式

    - 标记清除

        -
        标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
        -
        垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

    - 引用计数

        -
        另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来
        - 这种方法会引起循环引用的问题：例如：
          obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用

            -

- 减少垃圾回收

    - 对数组进行优化

        - 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的

    - 对object进行优化

        - 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收

    - 对函数进行优化

        - 在循环中的函数表达式，如果可以复用，尽量放在函数的外面

### **哪些情况会导致内存泄漏**

- 意外的全局变量

    - 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收

- 被遗忘的计时器或回调函数

    - 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收

- 脱离 DOM 的引用

    - 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收

- 闭包

    - 不合理的使用闭包，从而导致某些变量一直被留在内存当中

