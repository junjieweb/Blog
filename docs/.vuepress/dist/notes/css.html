<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.37">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/Front-end-Developer/images/favicon.ico"><title>CSS | Junjie</title><meta name="description" content="Front-end web developer">
    <link rel="modulepreload" href="/Front-end-Developer/assets/app.c6770391.js"><link rel="modulepreload" href="/Front-end-Developer/assets/css.html.a157a922.js"><link rel="modulepreload" href="/Front-end-Developer/assets/css.html.edbc8119.js"><link rel="modulepreload" href="/Front-end-Developer/assets/specifishity.400a9be0.js">
    <link rel="stylesheet" href="/Front-end-Developer/assets/style.aadac3e2.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/Front-end-Developer/" class=""><img class="logo" src="/Front-end-Developer/images/logo.svg" alt="Junjie"><span class="site-name can-hide">Junjie</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/Front-end-Developer/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/Front-end-Developer/notes/" class="router-link-active" aria-label="笔记"><!--[--><!--]--> 笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/Front-end-Developer/interview/" class="" aria-label="面试题"><!--[--><!--]--> 面试题 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/Front-end-Developer/yuque/" class="" aria-label="雨雀面试题"><!--[--><!--]--> 雨雀面试题 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/Front-end-Developer/resume/" class="" aria-label="简历"><!--[--><!--]--> 简历 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://v2.vuepress.vuejs.org/zh" rel="noopener noreferrer" target="_blank" aria-label="VuePress"><!--[--><!--]--> VuePress <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.github.com/junjieweb/Front-end-Developer" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/Front-end-Developer/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/Front-end-Developer/notes/" class="router-link-active" aria-label="笔记"><!--[--><!--]--> 笔记 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/Front-end-Developer/interview/" class="" aria-label="面试题"><!--[--><!--]--> 面试题 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/Front-end-Developer/yuque/" class="" aria-label="雨雀面试题"><!--[--><!--]--> 雨雀面试题 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/Front-end-Developer/resume/" class="" aria-label="简历"><!--[--><!--]--> 简历 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://v2.vuepress.vuejs.org/zh" rel="noopener noreferrer" target="_blank" aria-label="VuePress"><!--[--><!--]--> VuePress <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.github.com/junjieweb/Front-end-Developer" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">MDN <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/Front-end-Developer/notes/MDN/MDN.html" class="sidebar-item" aria-label="Web 和 Web标准"><!--[--><!--]--> Web 和 Web标准 <!--[--><!--]--></a><!----></li><li><a href="/Front-end-Developer/notes/MDN/line.html" class="sidebar-item" aria-label="MDN 学习路线"><!--[--><!--]--> MDN 学习路线 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading active collapsible">笔记 <span class="down arrow"></span></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/Front-end-Developer/notes/html.html" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="简介"><!--[--><!--]--> 简介 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#css-语法" class="router-link-active router-link-exact-active sidebar-item" aria-label="CSS 语法"><!--[--><!--]--> CSS 语法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#选择器" class="router-link-active router-link-exact-active sidebar-item" aria-label="选择器"><!--[--><!--]--> 选择器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#盒模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="盒模型"><!--[--><!--]--> 盒模型 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#什么是css-盒模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="什么是CSS 盒模型?"><!--[--><!--]--> 什么是CSS 盒模型? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#盒模型的各个部分" class="router-link-active router-link-exact-active sidebar-item" aria-label="盒模型的各个部分"><!--[--><!--]--> 盒模型的各个部分 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#标准盒模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="标准盒模型"><!--[--><!--]--> 标准盒模型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#替代-ie-盒模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="替代（IE）盒模型"><!--[--><!--]--> 替代（IE）盒模型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#外边距-内边距-边框" class="router-link-active router-link-exact-active sidebar-item" aria-label="外边距，内边距，边框"><!--[--><!--]--> 外边距，内边距，边框 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#overflow" class="router-link-active router-link-exact-active sidebar-item" aria-label="overflow"><!--[--><!--]--> overflow <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#display" class="router-link-active router-link-exact-active sidebar-item" aria-label="display"><!--[--><!--]--> display <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#bfc" class="router-link-active router-link-exact-active sidebar-item" aria-label="BFC"><!--[--><!--]--> BFC <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#浮动-float" class="router-link-active router-link-exact-active sidebar-item" aria-label="浮动 float"><!--[--><!--]--> 浮动 float <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#定位-position" class="router-link-active router-link-exact-active sidebar-item" aria-label="定位 position"><!--[--><!--]--> 定位 position <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#弹性盒-flex" class="router-link-active router-link-exact-active sidebar-item" aria-label="弹性盒 flex"><!--[--><!--]--> 弹性盒 flex <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#flex-模型说明" class="router-link-active router-link-exact-active sidebar-item" aria-label="flex 模型说明"><!--[--><!--]--> flex 模型说明 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#flex-容器相关属性" class="router-link-active router-link-exact-active sidebar-item" aria-label="flex 容器相关属性"><!--[--><!--]--> flex 容器相关属性 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Front-end-Developer/notes/css.html#flex-元素相关属性" class="router-link-active router-link-exact-active sidebar-item" aria-label="flex 元素相关属性"><!--[--><!--]--> flex 元素相关属性 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><li><a href="/Front-end-Developer/notes/js.html" class="sidebar-item" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><!----></li><li><a href="/Front-end-Developer/notes/vue/vue2_base.html" class="sidebar-item" aria-label="Vue2基础"><!--[--><!--]--> Vue2基础 <!--[--><!--]--></a><!----></li><li><a href="/Front-end-Developer/notes/vue/vue2_cli.html" class="sidebar-item" aria-label="Vue2脚手架"><!--[--><!--]--> Vue2脚手架 <!--[--><!--]--></a><!----></li><li><a href="/Front-end-Developer/notes/vue/vue3.html" class="sidebar-item" aria-label="Vue3快速上手"><!--[--><!--]--> Vue3快速上手 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">HTML <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/Front-end-Developer/notes/html/" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading collapsible">CSS <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/Front-end-Developer/notes/css/" class="sidebar-item" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="css" tabindex="-1"><a class="header-anchor" href="#css" aria-hidden="true">#</a> CSS</h1><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p><strong>层叠样式表</strong> (Cascading Style Sheets，缩写为 <strong>CSS</strong>），用于设置和布置网页 - 例如，更改内容的字体，颜色，大小和间距，将其拆分为多个列，或添加动画和其他装饰功能。</p><p>CSS 是<strong>开放网络</strong>的核心语言之一，由 <a href="https://w3.org/Style/CSS/#specs" target="_blank" rel="noopener noreferrer">W3C 规范<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 实现跨浏览器的标准化。CSS节省了大量的工作。 样式可以通过定义保存在外部.css文件中，同时控制多个网页的布局，这意味着开发者不必经历在所有网页上编辑布局的麻烦。CSS 被分为不同等级：CSS1 现已废弃， CSS2.1 是推荐标准， <a href="https://developer.mozilla.org//docs/CSS/CSS3" target="_blank" rel="noopener noreferrer">CSS3<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 分成多个小模块且正在标准化中。</p><h4 id="编写的位置" tabindex="-1"><a class="header-anchor" href="#编写的位置" aria-hidden="true">#</a> 编写的位置</h4><ol><li><p>第一种：内联样式：可将css代码编写到标签的style属性中</p><p><code>&lt;p style=&quot;color: red; font-size: 30px;&quot;&gt;海内存知己，天涯若比邻！&lt;/p&gt;</code></p></li><li><p>第二种：内部样式表：可以将css代码编写到一个style标签中</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
    <span class="token selector">p</span> <span class="token punctuation">{</span>
        <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
        <span class="token property">font-size</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>
        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p>第三种：外部样式表：可以将css代码编写到一个外部文件中，然后通过link标签引入</p><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;</code></p></li></ol><h2 id="css-语法" tabindex="-1"><a class="header-anchor" href="#css-语法" aria-hidden="true">#</a> CSS 语法</h2><p>和 HTML 类似，CSS 也不是真正的编程语言，甚至不是标记语言。它是一门样式表语言，这也就是说人们可以用它来选择性地为 HTML 元素添加样式。举例来说，要选择一个 HTML 页面里所有的段落元素，然后将其中的文本改成红色，可以这样写 CSS：</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">p</span> <span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="css-规则集-详解" tabindex="-1"><a class="header-anchor" href="#css-规则集-详解" aria-hidden="true">#</a> “CSS 规则集”详解</h4><p>让我们来仔细看一看上述CSS：</p><p><img src="https://mdn.mozillademos.org/files/16483/css-declaration.png" alt="图解CSS声明"></p><p>整个结构称为 <strong>规则集</strong>（通常简称“规则”），各部分释义如下：</p><ul><li><p>选择器（Selector）</p><p>HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素（在这个例子中就是 <code>p</code> 元素）。要给不同元素添加样式只需要更改选择器就行了。</p></li><li><p>声明（<strong>Declaration</strong>）</p><p>一个单独的规则，如 <code>color: red;</code> 用来指定添加样式元素的<strong>属性</strong>。</p></li><li><p>属性（<strong>Properties</strong>）</p><p>改变 HTML 元素样式的途径。（本例中 <code>color</code> 就是元素的属性。）CSS 中，由编写人员决定修改哪个属性以改变规则。</p></li><li><p>属性的值（Property value）</p><p>在属性的右边，冒号后面即<strong>属性的值</strong>，它从指定属性的众多外观中选择一个值（我们除了 <code>red</code> 之外还有很多属性值可以用于 <code>color</code> ）。</p></li></ul><p>注意其他重要的语法：</p><ul><li>每个规则集（除了选择器的部分）都应该包含在成对的大括号里（<code>{}</code>）。</li><li>在每个声明里要用冒号（<code>:</code>）将属性与属性值分隔开。</li><li>在每个规则集里要用分号（<code>;</code>）将各个声明分隔开。</li></ul><p>如果要同时修改多个属性，只需要将它们用分号隔开，就像这样：</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">p</span> <span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="多元素选择" tabindex="-1"><a class="header-anchor" href="#多元素选择" aria-hidden="true">#</a> 多元素选择</h4><p>也可以选择多种类型的元素并为它们添加一组相同的样式。将不同的选择器用逗号分开。例如：</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">p, li, h1</span> <span class="token punctuation">{</span>
    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="选择器" tabindex="-1"><a class="header-anchor" href="#选择器" aria-hidden="true">#</a> 选择器</h2><p>CSS选择器是CSS规则的第一部分。它是元素和其他部分组合起来告诉浏览器哪个HTML元素应当是被选为应用规则中的CSS属性值的方式。选择器所选择的元素，叫做“选择器的对象”。</p><table><thead><tr><th style="text-align:left;">选择器名称</th><th style="text-align:left;">选择的内容</th><th style="text-align:left;">示例</th></tr></thead><tbody><tr><td style="text-align:left;">通配选择器</td><td style="text-align:left;">选中页面中的所有元素</td><td style="text-align:left;"><code>*{}</code></td></tr><tr><td style="text-align:left;">元素选择器（也称作标签或类型选择器）</td><td style="text-align:left;">所有指定(该)类型的 HTML 元素</td><td style="text-align:left;"><code>p{}</code></td></tr><tr><td style="text-align:left;">ID 选择器</td><td style="text-align:left;">具有特定 ID 的元素</td><td style="text-align:left;"><code>#my-id{}</code></td></tr><tr><td style="text-align:left;">类选择器</td><td style="text-align:left;">具有特定类的元素</td><td style="text-align:left;"><code>.my-class{}</code></td></tr><tr><td style="text-align:left;">属性选择器</td><td style="text-align:left;">拥有特定属性的元素</td><td style="text-align:left;"><code>a[title]{}</code></td></tr><tr><td style="text-align:left;">选择器列表</td><td style="text-align:left;">同时选择多个选择器对应的元素</td><td style="text-align:left;"><code>div,p,span{}</code></td></tr><tr><td style="text-align:left;">子元素选择器</td><td style="text-align:left;">选择指定父元素的指定子元素</td><td style="text-align:left;"><code>ul &gt; li{}</code></td></tr><tr><td style="text-align:left;">后代元素选择器</td><td style="text-align:left;">选中指定元素内的指定后代元素</td><td style="text-align:left;"><code>div span{}</code></td></tr><tr><td style="text-align:left;">相邻兄弟选择器</td><td style="text-align:left;">选择指定元素第一个指定兄弟元素</td><td style="text-align:left;"><code>div + p{}</code></td></tr><tr><td style="text-align:left;">通用兄弟选择器</td><td style="text-align:left;">指定元素所有指定兄弟元素</td><td style="text-align:left;"><code>div ~ p{}</code></td></tr><tr><td style="text-align:left;">属性选择器</td><td style="text-align:left;">含有指定属性的元素</td><td style="text-align:left;"><code>a[title]{}</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">含有指定属性和属性值的元素</td><td style="text-align:left;"><code>a[ref=&quot;value&quot;]{}</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">指定属性值以指定值开头的元素</td><td style="text-align:left;"><code>a[ref^=&quot;value&quot;]{}</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">指定属性值以指定值结尾的元素</td><td style="text-align:left;"><code>a[ref$=&quot;value&quot;]{}</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">指定属性值含有指定值的元素</td><td style="text-align:left;"><code>a[ref*=&quot;value&quot;]{}</code></td></tr><tr><td style="text-align:left;">伪元素选择器</td><td style="text-align:left;">元素内部的开始位置</td><td style="text-align:left;"><code>p::before{}</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">元素内部的结束位置</td><td style="text-align:left;"><code>p::after{}</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">元素内部的结束位置</td><td style="text-align:left;"><code>p::after{}</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">第一行</td><td style="text-align:left;"><code>p::first-line{}</code></td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;">第一个字母（汉字）</td><td style="text-align:left;"><code>p::first-letter{}</code></td></tr></tbody></table><blockquote><p><strong>伪元素</strong>，表示页面中一些特殊的并不真实存在的元素（特殊的位置），伪元素使用 <code>::</code> 开头。</p><p><strong>伪类</strong>（不存在的类，特殊的类），伪类用来描述一个元素的特殊状态，伪类一般情况下都是使用<code>:</code>开头</p></blockquote><h4 id="伪类选择器" tabindex="-1"><a class="header-anchor" href="#伪类选择器" aria-hidden="true">#</a> 伪类选择器</h4><ul><li><code>:first-child</code> 第一个子元素</li><li><code>:first-of-type</code> 同类型的第一个子元素</li><li><code>:last-child</code> 最后一个子元素</li><li><code>:last-of-type</code> 同类型的最后一个子元素</li><li><code>:nth-child(n)</code> 选中第n个子元素</li><li><code>:nth-of-type(n)</code> 同类型的第N个子元素</li><li><code>:only-child</code> 唯一的子元素</li><li><code>:only-of-type</code> 同类型中唯一的子元素</li><li><code>:empty</code> 空元素</li><li><code>:not()</code> 除了</li><li><code>:link</code> 正常的链接（没访问过的链接）</li><li><code>:visited</code> 访问过的链接</li><li><code>:hover</code> 鼠标移入的状态</li><li><code>:active</code> 鼠标点击的状态</li></ul><h4 id="选择器优先级" tabindex="-1"><a class="header-anchor" href="#选择器优先级" aria-hidden="true">#</a> 选择器优先级</h4><p>当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突。 发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定。</p><blockquote><p>继承的样式（无） &gt; 通配选择器（0） &gt; 标签选择器（1） &gt; 类选择器（10） &gt; id选择器（100） &gt; 行内样式（1000） &gt; !important（10000）</p></blockquote><p>比较优先级时，需要将所有的选择器的优先级相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的）。 选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器，如果优先级计算后相等，此时则优先使用靠下的样式。</p><p>可以在某一个样式的后面添加 <code>!important</code>，则此时该样式会获取到最高的优先级，甚至超过内联样式。</p><p>注意：在开发中这个一定要慎用</p><p><img src="/Front-end-Developer/images/css/specifishity.png" alt="specifishity"></p><h2 id="盒模型" tabindex="-1"><a class="header-anchor" href="#盒模型" aria-hidden="true">#</a> 盒模型</h2><p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，是我们使用CSS实现准确布局、处理元素排列的关键。</p><h4 id="块级盒子-block-box-和-内联盒子-inline-box" tabindex="-1"><a class="header-anchor" href="#块级盒子-block-box-和-内联盒子-inline-box" aria-hidden="true">#</a> 块级盒子（Block box） 和 内联盒子（Inline box）</h4><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (<strong>block box</strong>) 和 <strong>内联盒子</strong> (<strong>inline box</strong>)<strong>。<strong>这两种盒子会在</strong>页面流</strong>（page flow）和<strong>元素之间的关系</strong> 方面表现出不同的行为:</p><p><strong>一个被定义成块级的（block）盒子会表现出以下行为:</strong></p><ul><li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li><li>每个盒子都会换行</li><li><code>width</code>和 <code>height</code>属性可以发挥作用</li><li>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</li></ul><p>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)和段落(<code>&lt;p&gt;</code>)默认情况下都是块级的盒子。</p><p><strong>如果一个盒子对外显示为 <code>inline</code>，那么他的行为如下:</strong></p><ul><li>盒子不会产生换行。</li><li><code>width</code>和 <code>height</code>属性将不起作用。</li><li>垂直方向的内边距、外边距以及边框会被应用，但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li><li>水平方向的内边距、外边距以及边框会被应用，且会把其他处于 <code>inline</code> 状态的盒子推开。</li></ul><p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p><p>我们通过对盒子<code>display</code>属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p><h3 id="什么是css-盒模型" tabindex="-1"><a class="header-anchor" href="#什么是css-盒模型" aria-hidden="true">#</a> 什么是CSS 盒模型?</h3><p>完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。</p><h3 id="盒模型的各个部分" tabindex="-1"><a class="header-anchor" href="#盒模型的各个部分" aria-hidden="true">#</a> 盒模型的各个部分</h3><p>CSS中组成一个块级盒子需要:</p><ul><li><strong>Content box</strong>: 这个区域是用来显示内容，大小可以通过设置<code>width</code>和<code>height</code>.</li><li><strong>Padding box</strong>: 包围在内容区域外部的空白区域； 大小通过 <code>padding</code>相关属性设置。</li><li><strong>Border box</strong>: 边框盒包裹内容和内边距。大小通过 <code>border</code>相关属性设置。</li><li><strong>Margin box</strong>: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <code>margin</code>相关属性设置。</li></ul><p>如下图：</p><p><img src="https://mdn.mozillademos.org/files/16558/box-model.png" alt="Diagram of the box model"></p><h3 id="标准盒模型" tabindex="-1"><a class="header-anchor" href="#标准盒模型" aria-hidden="true">#</a> 标准盒模型</h3><p>在标准模型中，如果你给盒设置 <code>width</code> 和 <code>height</code>，实际设置的是 <em>content box</em>。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。 见下图。</p><p>假设定义了 <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>, and <code>padding</code>:</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 350px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 25px<span class="token punctuation">;</span>
    <span class="token property">padding</span><span class="token punctuation">:</span> 25px<span class="token punctuation">;</span>
    <span class="token property">border</span><span class="token punctuation">:</span> 5px solid black<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>如果使用标准模型宽度 = 410px (350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box。</p><p><img src="https://mdn.mozillademos.org/files/16559/standard-box-model.png" alt="Showing the size of the box when the standard box model is being used."></p><blockquote><p><strong>注</strong>: margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到margin。</p></blockquote><h3 id="替代-ie-盒模型" tabindex="-1"><a class="header-anchor" href="#替代-ie-盒模型" aria-hidden="true">#</a> 替代（IE）盒模型</h3><p>你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的! 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width = 350px, height = 150px).</p><p><img src="https://mdn.mozillademos.org/files/16557/alternate-box-model.png" alt="Showing the size of the box when the alternate box model is being used."></p><p>默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 <code>box-sizing: border-box</code> 来实现。 这样就可以告诉浏览器使用 <code>border-box</code> 来定义区域，从而设定您想要的大小。</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
    <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果你希望所有元素都使用替代模式，而且确实很常用，设置 <code>box-sizing</code> 在 <code>&lt;html&gt;</code> 元素上，然后设置所有元素继承该属性，正如下面的例子。如果想要深入理解，请看 <a href="https://css-tricks.com/inheriting-box-sizing-probably-slightly-better-best-practice/" target="_blank" rel="noopener noreferrer">the CSS Tricks article on box-sizing<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 。</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">html</span> <span class="token punctuation">{</span>
    <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">*, *::before, *::after</span> <span class="token punctuation">{</span>
    <span class="token property">box-sizing</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>注：</strong> 一个有趣的历史记录 ——Internet Explorer默认使用替代盒模型，没有可用的机制来切换。（译者注：IE8+ 支持使用<code>box-sizing</code> 进行切换 ）</p><h3 id="外边距-内边距-边框" tabindex="-1"><a class="header-anchor" href="#外边距-内边距-边框" aria-hidden="true">#</a> 外边距，内边距，边框</h3><h4 id="外边距" tabindex="-1"><a class="header-anchor" href="#外边距" aria-hidden="true">#</a> 外边距</h4><p>外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。 外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。无论使用标准模型还是替代模型，外边距总是在计算可见部分后额外添加。</p><p>我们可以使用<code>margin</code>属性一次控制一个元素的所有边距，或者每边单独使用等价的普通属性控制：</p><ul><li><code>margin-top</code></li><li><code>margin-right</code></li><li><code>margin-bottom</code></li><li><code>margin-left</code></li></ul><h4 id="外边距折叠" tabindex="-1"><a class="header-anchor" href="#外边距折叠" aria-hidden="true">#</a> 外边距折叠</h4><p>理解外边距的一个关键是外边距折叠的概念。如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。</p><p>有许多规则规定了什么时候外边距会折叠，什么时候不会折叠。相关更多信息，请参阅 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener noreferrer">mastering margin collapsing<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 。现在首先要记住的事情是，外边距会折叠这个事情。如果你用外边距创建空间而没有得到你想要的效果，那这可能就是这个原因。</p><h4 id="边框" tabindex="-1"><a class="header-anchor" href="#边框" aria-hidden="true">#</a> 边框</h4><p>边框是在边距和填充框之间绘制的。如果您正在使用标准的盒模型，边框的大小将添加到框的宽度和高度。如果您使用的是替代盒模型，那么边框的大小会使内容框更小，因为它会占用一些可用的宽度和高度。</p><p>为边框设置样式时，有大量的属性可以使用——有四个边框，每个边框都有样式、宽度和颜色，我们可能需要对它们进行操作。</p><p>可以使用<code>border</code>属性一次设置所有四个边框的宽度、颜色和样式。</p><p>分别设置每边的宽度、颜色和样式，可以使用：</p><ul><li><code>border-top</code></li><li><code>border-right</code></li><li><code>border-bottom</code></li><li><code>border-left</code></li></ul><p>设置所有边的颜色、样式或宽度，请使用以下属性：</p><ul><li><code>border-width</code></li><li><code>border-style</code></li><li><code>border-color</code></li></ul><p>设置单边的颜色、样式或宽度，可以使用最细粒度的普通属性之一：</p><ul><li><code>border-top-width</code></li><li><code>border-top-style</code></li><li><code>border-top-color</code></li><li><code>border-right-width</code></li><li><code>border-right-style</code></li><li><code>border-right-color</code></li><li><code>border-bottom-width</code></li><li><code>border-bottom-style</code></li><li><code>border-bottom-color</code></li><li><code>border-left-width</code></li><li><code>border-left-style</code></li><li><code>border-left-color</code></li></ul><h4 id="内边距" tabindex="-1"><a class="header-anchor" href="#内边距" aria-hidden="true">#</a> 内边距</h4><p>内边距位于边框和内容区域之间。与外边距不同，您不能有负数量的内边距，所以值必须是0或正的值。应用于元素的任何背景都将显示在内边距后面，内边距通常用于将内容推离边框。</p><p>我们可以使用<code>padding</code>简写属性控制元素所有边，或者每边单独使用等价的普通属性：</p><ul><li><code>padding-top</code></li><li><code>padding-right</code></li><li><code>padding-bottom</code></li><li><code>padding-left</code></li></ul><h4 id="使用display-inline-block" tabindex="-1"><a class="header-anchor" href="#使用display-inline-block" aria-hidden="true">#</a> 使用display: inline-block</h4><p>display有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用:您不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。</p><p>一个元素使用 <code>display: inline-block</code>，实现我们需要的块级的部分效果：</p><ul><li>设置<code>width</code> 和<code>height</code> 属性会生效。</li><li><code>padding</code>, <code>margin</code>, 以及<code>border</code> 会推开其他元素。</li></ul><p>但是，它不会跳转到新行，如果显式添加<code>width</code> 和<code>height</code> 属性，它只会变得比其内容更大。</p><p>当您想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。<code>&lt;a&gt;</code>是像<code>&lt;span</code>&gt;一样的内联元素；你可以使用<code>display: inline-block</code>来设置内边距，让用户更容易点击链接。</p><h3 id="overflow" tabindex="-1"><a class="header-anchor" href="#overflow" aria-hidden="true">#</a> overflow</h3><p><code>overflow</code>属性是你控制一个元素溢出的方式，它告诉浏览器你想怎样处理溢出。</p><ul><li><code>visible</code> 默认值，不处理溢出的内容，在盒子外部显示</li><li><code>hidden</code> 溢出的内容会被裁剪，不在页面中显示</li><li><code>scroll</code> 生成水平和垂直双方向滚动条</li><li><code>auto</code> 根据需要生成滚动条</li></ul><h3 id="display" tabindex="-1"><a class="header-anchor" href="#display" aria-hidden="true">#</a> display</h3><p><code>display</code> 属性可以设置元素的内部和外部显示类型。</p><ul><li><code>block</code> 元素作为块元素显示</li><li><code>inline</code> 元素作为行内元素显示</li><li><code>inline-block</code> 元素作为行内块元素显示</li><li><code>none</code> 元素不在页面中显示</li><li><code>table</code> 元素会作为一个表格显示</li><li><code>flex</code> 元素会作为一个弹性容器显示</li><li><code>inline-flex</code> 元素会作为行内弹性容器显示</li></ul><h2 id="bfc" tabindex="-1"><a class="header-anchor" href="#bfc" aria-hidden="true">#</a> BFC</h2><p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 如果一个元素具有BFC，内部元素再怎么弄，都不会影响到外面的元素</p><p>下列方式会创建<strong>块格式化上下文</strong>：</p><ul><li>根元素（<code>&lt;html&gt;）</code></li><li>浮动元素（元素的 <code>float</code> 不是 <code>none</code>）</li><li>绝对定位元素（元素的 <code>position</code>为 <code>absolute</code> 或 <code>fixed</code>）</li><li>行内块元素（元素的 <code>display</code>为 <code>inline-block</code>）</li><li>表格单元格（元素的 <code>display</code> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li><li>表格标题（元素的 <code>display</code> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li><li>匿名表格单元格元素（元素的 <code>display</code> 为 <code>table</code>、<code>table-row</code>、 <code>table-row-group</code>、<code>table-header-group</code>、<code>table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li><li><code>overflow</code>计算值(Computed)不为 <code>visible</code> 的块元素</li><li><code>display</code>值为 <code>flow-root</code> 的元素</li><li><code>contain</code>值为 <code>layout</code>、<code>content </code>或 paint 的元素</li><li>弹性元素（<code>display</code>为 <code>flex</code> 或 <code>inline-flex </code>元素的直接子元素）</li><li>网格元素（<code>display</code> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li><li>多列容器（元素的 <code>column-count</code>或 <code>column-width</code> 不为 <code>auto，包括 ``column-count</code> 为 <code>1</code>）</li><li><code>column-span</code> 为 <code>all</code>的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中。</li></ul><p>块格式化上下文包含创建它的元素内部的所有内容.</p><p>块格式化上下文对浮动定位<code>float</code>与清除浮动<code>clear</code> 都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener noreferrer">Margin collapsing<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> ）也只会发生在属于同一BFC的块级元素之间。</p><h2 id="浮动-float" tabindex="-1"><a class="header-anchor" href="#浮动-float" aria-hidden="true">#</a> 浮动 float</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float" target="_blank" rel="noopener noreferrer">float<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> CSS 属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动（文档流）中移除，尽管仍然保持部分的流动性（与绝对定位相反）。</p><p><code>float: none;</code> <code>float: left;</code> <code>float: right;</code></p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token comment">/* 清除浮动 */</span>
<span class="token selector">.clearfix::after</span> <span class="token punctuation">{</span>
    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">;</span>
    <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>
    <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="定位-position" tabindex="-1"><a class="header-anchor" href="#定位-position" aria-hidden="true">#</a> 定位 position</h2><p>CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener noreferrer">position<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 属性用于指定一个元素在文档中的定位方式。<code>top</code>，<code>right</code>，<code>bottom</code> 和 <code>left</code> 属性则决定了该元素的最终位置。</p><h4 id="定位类型" tabindex="-1"><a class="header-anchor" href="#定位类型" aria-hidden="true">#</a> 定位类型</h4><ul><li><strong>定位元素（positioned element）</strong> 是其计算后位置属性为 <code>relative</code>, <code>absolute</code>, <code>fixed</code> 或 <code>sticky</code> 的一个元素（换句话说，除static以外的任何东西）。</li><li><strong>相对定位元素（relatively positioned element）</strong> 是计算后位置属性为 <code>relative</code> 的元素。</li><li><strong>绝对定位元素（absolutely positioned element）</strong> 是计算后位置属性为 <code>absolute</code> 或 <code>fixed</code> 的元素。</li><li><strong>粘性定位元素（stickily positioned element）</strong> 是计算后位置属性为 <code>sticky</code> 的元素。</li></ul><h4 id="相对定位position-relative" tabindex="-1"><a class="header-anchor" href="#相对定位position-relative" aria-hidden="true">#</a> 相对定位<code>position: relative</code></h4><ol><li>不设置偏移量元素不会发生变化</li><li>元素不会脱离文档流</li><li>不会改变元素的性质</li><li>元素会提升一个层级</li><li>相对于自身在文档流中的位置进行定位</li></ol><h4 id="绝对定位position-absolute" tabindex="-1"><a class="header-anchor" href="#绝对定位position-absolute" aria-hidden="true">#</a> 绝对定位<code>position: absolute;</code></h4><ol><li>不设置偏移量元素不会发生变化</li><li>元素会脱离文档流</li><li>会改变元素性质，行内元素变块元素，块元素高度被内容撑开</li><li>元素会提升一个等级</li><li>相对其包含块进行定位 <ol><li>初始包含块：<code>html</code>根元素</li><li>默认包含块是离当前元素最近的祖先元素</li><li>对于绝对定位元素，包含快是离它最近的开启了定位的祖先元素。如果所有元素都没有开启定位，则其包含块就是初始包含块</li></ol></li></ol><h4 id="固定定位position-fixed" tabindex="-1"><a class="header-anchor" href="#固定定位position-fixed" aria-hidden="true">#</a> 固定定位<code>position: fixed;</code></h4><ol><li>大部分特点和绝对定位一样</li><li>相对于视口进行定位的</li><li>会固定在网页的视口上，不会随网页滚动</li></ol><h4 id="定位的水平垂直居中" tabindex="-1"><a class="header-anchor" href="#定位的水平垂直居中" aria-hidden="true">#</a> 定位的水平垂直居中</h4><p>水平居中：<code>left: 50%;</code> 走父元素宽度的一半，<code>margin-left: -自身宽度/2;</code>，往回走。</p><p>垂直居中：<code>top: 50%;</code> 走父元素高度的一半，<code>margin-top: -自身高度/2;</code>，往回走。</p><h2 id="弹性盒-flex" tabindex="-1"><a class="header-anchor" href="#弹性盒-flex" aria-hidden="true">#</a> 弹性盒 flex</h2><p>弹性盒子是一种用于按行或按列布局元素的一维布局方法 。元素可以膨胀以填充额外的空间, 收缩以适应更小的空间。</p><p>使用弹性盒，必须先设置弹性盒容器：<code>display: flex;</code> 或 <code>display: inline-flex;</code></p><h3 id="flex-模型说明" tabindex="-1"><a class="header-anchor" href="#flex-模型说明" aria-hidden="true">#</a> flex 模型说明</h3><p>当元素表现为 flex 框时，它们沿着两个轴来布局：</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox/flex_terms.png" alt="flex_terms.png"></p><ul><li><p><strong>弹性容器</strong>：设置了<code>display:flex;</code> 或 <code>display: inline-flex;</code> 的元素称为 <strong>flex 容器（flex container）。</strong></p></li><li><p><strong>弹性元素</strong>：设置了 <code>display:flex;</code> 元素的子元素称为 <strong>flex 项</strong>（<strong>flex item</strong>）。</p><ul><li>弹性盒可以嵌套，一个元素可以是弹性容器，也可以是弹性元素</li></ul></li><li><p><strong>主轴（main axis）</strong>：弹性元素的排列方向称为主轴。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</p></li><li><p><strong>侧轴（cross axis）</strong>：与主轴垂直方向的称为侧轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</p></li></ul><h3 id="flex-容器相关属性" tabindex="-1"><a class="header-anchor" href="#flex-容器相关属性" aria-hidden="true">#</a> flex 容器相关属性</h3><h4 id="弹性容器中弹性元素的排列方式-flex-direction。" tabindex="-1"><a class="header-anchor" href="#弹性容器中弹性元素的排列方式-flex-direction。" aria-hidden="true">#</a> 弹性容器中弹性元素的排列方式 <code>flex-direction</code>。</h4><p><code>flex-direction: row | row-reverse | column | column-reverse;</code></p><ul><li><p><code>row</code>：默认值，弹性元素在容器中水平排列，自左向右。（主轴：自左向右）</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;">3</li></ul></li><li><p><code>row-reverse</code>：弹性元素在容器中反向水平排列，自右向左。（主轴：自右向左）</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row-reverse;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;">3</li></ul></li><li><p><code>column</code>：弹性元素纵向排列，自上向下。（主轴：自上向下）</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:column;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;">3</li></ul></li><li><p><code>column-reverse</code>：弹性元素反向纵向排列，自下向上。（主轴：自下向上）</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:column-reverse;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;">3</li></ul></li></ul><h4 id="弹性容器中弹性元素的换行方式" tabindex="-1"><a class="header-anchor" href="#弹性容器中弹性元素的换行方式" aria-hidden="true">#</a> 弹性容器中弹性元素的换行方式</h4><p><code>flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit;</code></p><ul><li><p><code>nowrap</code> - 默认值，溢出部分不换行。</p><ul style="margin:0;padding:0;width:120px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul></li><li><p><code>wrap</code> - 沿着侧轴方向自动换行。</p><ul style="margin:0;padding:0;width:120px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;flex-wrap:wrap;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul></li><li><p><code>wrap-reverse</code> - 沿着侧轴反向自动换行。</p><ul style="margin:0;padding:0;width:120px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;flex-wrap:wrap-reverse;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul></li></ul><h4 id="简写属性-flex-flow" tabindex="-1"><a class="header-anchor" href="#简写属性-flex-flow" aria-hidden="true">#</a> 简写属性 flex-flow</h4><p><code>flex-direction</code> 和 <code>flex-wrap</code> — 的缩写 <code>flex-flow</code>。可以同时设置排列方式和换行方式。</p><p><code>flex-direction: row;</code> 和 <code>flex-wrap: wrap;</code> 可以替换为 <code>flex-flow: row wrap;</code>，没有前后顺序要求。</p><h4 id="主轴上元素的对齐方式" tabindex="-1"><a class="header-anchor" href="#主轴上元素的对齐方式" aria-hidden="true">#</a> 主轴上元素的对齐方式</h4><p><code>justify-content: flex-start | flex-end | center | space-between | space-around;</code></p><ul><li><p><code>flex-start</code>：元素沿着主轴的起边排列。</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;justify-content:flex-start;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul></li><li><p><code>flex-end</code>：元素沿着主轴的终边排列。</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;justify-content:flex-end;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul></li><li><p><code>center</code>：弹性元素居中排列。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;justify-content:center;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul><ul><li><p>如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出。</p><ul style="margin:0;padding:0;width:100px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;justify-content:center;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul></li></ul></li><li><p><code>space-between</code> ：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;justify-content:space-between;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul></li><li><p><code>space-around</code> ：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2* 20px=10px）。</p><ul style="margin:0;padding:0;width:300px;border:#777777 1px solid;list-style:none;display:flex;flex-direction:row;justify-content:space-around;"><li style="width:50px;height:30px;background:#bbffcc;text-align:center;line-height:30px;flex-shrink:0;">1</li><li style="width:50px;height:30px;background:pink;text-align:center;line-height:30px;flex-shrink:0;">2</li><li style="width:50px;height:30px;background:orange;text-align:center;line-height:30px;flex-shrink:0;">3</li></ul></li></ul><h4 id="侧轴上元素的对齐方式" tabindex="-1"><a class="header-anchor" href="#侧轴上元素的对齐方式" aria-hidden="true">#</a> 侧轴上元素的对齐方式</h4><p><code>align-items: flex-start | flex-end | center | baseline | stretch;</code></p><p><code>align-self</code>，用来覆盖当前弹性元素上的 <code>align-items</code></p><ul><li><p><code>stretch</code>：默认值，将元素的长度设置为相同的值。如果指定侧轴大小的属性值为<code>auto</code>，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照<code>min/max-width/height</code>属性的限制。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:stretch;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>flex-start</code>：沿侧轴起边对齐。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:flex-start;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>flex-end</code>：沿侧轴终边对齐。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:flex-end;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>center</code>：居中对齐。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:center;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>baseline</code>：基线对齐。如弹性盒子元素的行内轴与侧轴为同一条，则该值与&#39;<code>flex-start</code>&#39;等效。其它情况下，该值将参与基线对齐。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:baseline;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li></ul><h4 id="侧轴元素额外空间的分配" tabindex="-1"><a class="header-anchor" href="#侧轴元素额外空间的分配" aria-hidden="true">#</a> 侧轴元素额外空间的分配</h4><p><code>align-content</code> 属性用于修改 <code>flex-wrap</code> 属性的行为。类似于 <code>align-items</code>, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐。</p><p><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</code></p><ul><li><p><code>stretch</code> - 默认。各行将会伸展以占用剩余的空间。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:flex-start;align-content:stretch;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>flex-start</code> - 各行向弹性盒容器的起始位置堆叠。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:flex-start;align-content:flex-start;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>flex-end</code> - 各行向弹性盒容器的结束位置堆叠。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:flex-start;align-content:flex-end;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>center</code> -各行向弹性盒容器的中间位置堆叠。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:flex-start;align-content:center;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>space-between</code> -各行在弹性盒容器中平均分布。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:flex-start;align-content:space-between;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li><li><p><code>space-around</code> - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。</p><ul style="margin:0;padding:0;width:150px;height:200px;border:#777777 1px solid;list-style:none;display:flex;flex-flow:row wrap;align-items:flex-start;align-content:space-around;"><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li><li style="width:50px;background:orange;text-align:center;">3<div>3</div><div>3</div></li><li style="width:50px;background:#bbffcc;text-align:center;">1</li><li style="width:50px;background:pink;text-align:center;">2<div>2</div></li></ul></li></ul><h3 id="flex-元素相关属性" tabindex="-1"><a class="header-anchor" href="#flex-元素相关属性" aria-hidden="true">#</a> flex 元素相关属性</h3><h4 id="指定弹性元素的伸展的系数-flex-grow" tabindex="-1"><a class="header-anchor" href="#指定弹性元素的伸展的系数-flex-grow" aria-hidden="true">#</a> 指定弹性元素的伸展的系数 <code>flex-grow</code></h4><p>当父元素有剩余空间时，子元素如何伸展，父元素的剩余空间会按照比例进行分配。</p><ul><li><code>flex-grow: 0;</code> 默认值0，不伸展。</li><li>值越大，伸展越多。</li></ul><h4 id="指定元素的收缩系数-flex-shrink" tabindex="-1"><a class="header-anchor" href="#指定元素的收缩系数-flex-shrink" aria-hidden="true">#</a> 指定元素的收缩系数 <code>flex-shrink</code></h4><p>当父元素中的空间不足以容纳所有的子元素时，如何对子元素进行收缩。</p><ul><li><code>flex-shrink: 1;</code> 默认值1，等比例收缩。</li><li><code>flex-shrink: 0;</code> 不收缩。</li><li>值越大，收缩越多。</li></ul><h4 id="指定弹性元素的弹性基准" tabindex="-1"><a class="header-anchor" href="#指定弹性元素的弹性基准" aria-hidden="true">#</a> 指定弹性元素的弹性基准</h4><p><code>flex-basis</code> 指定的是元素在主轴上的基础长度。</p><ul><li>默认值<code>auto</code>，表示参考元素自身的高度和宽度。</li><li>如果主轴是横向的，则该值指定的就是元素的宽度。</li><li>如果主轴是纵向的，则该值指定的就是元素的高度。</li></ul><h4 id="指定弹性元素的排列顺序" tabindex="-1"><a class="header-anchor" href="#指定弹性元素的排列顺序" aria-hidden="true">#</a> 指定弹性元素的排列顺序</h4><p><code>order: 0;</code></p><ul><li>所有 <code>flex</code> 项默认的 <code>order</code> 值是 0。</li><li>相同 order 值的 flex 项按源顺序显示。</li><li>用整数值来定义排列顺序，数值小的排在前面。可以为负值。</li></ul><h4 id="完美居中" tabindex="-1"><a class="header-anchor" href="#完美居中" aria-hidden="true">#</a> 完美居中</h4><p>使用弹性盒子，居中变的很简单，只需要设置弹性元素 <code>margin: auto;</code> 可以使得弹性元素在两上轴方向上完全居中</p><h4 id="弹性元素自身在侧轴方向上的对齐方式。" tabindex="-1"><a class="header-anchor" href="#弹性元素自身在侧轴方向上的对齐方式。" aria-hidden="true">#</a> 弹性元素自身在侧轴方向上的对齐方式。</h4><p>用来覆盖当前弹性元素上的 <code>align-items</code></p><p><code>align-self: auto | flex-start | flex-end | center | baseline | stretch</code></p><ul><li><code>auto</code>：如果<code>align-self</code>&#39;的值为<code>auto</code>，则其计算值为元素的父元素的<code>align-items</code>值，如果其没有父元素，则计算值为<code>stretch</code>。</li><li><code>flex-start</code>：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li><li><code>flex-end</code>：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li><li><code>center</code>：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li><li><code>baseline</code>：如弹性盒子元素的行内轴与侧轴为同一条，则该值与<code>flex-start</code>等效。其它情况下，该值将参与基线对齐。</li><li><code>stretch</code>：如果指定侧轴大小的属性值为<code>auto</code>，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照<code>min/max-width/height</code>属性的限制。</li></ul><h4 id="简写属性" tabindex="-1"><a class="header-anchor" href="#简写属性" aria-hidden="true">#</a> 简写属性</h4><p>flex 属性用于指定弹性子元素如何分配空间。</p><p><code>flex: auto | initial | none | inherit | [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]</code></p><p><code>flex: 增长 缩减 基准</code></p><ul><li><code>auto</code>: 计算值为 1 1 auto</li><li><code>initial</code>: 计算值为 0 1 auto</li><li><code>none</code>：计算值为 0 0 auto</li><li><code>inherit</code>：从父元素继承</li><li><code>[ flex-grow ]</code>：定义弹性盒子元素的扩展比率。</li><li><code>[ flex-shrink ]</code>：定义弹性盒子元素的收缩比率。</li><li><code>[ flex-basis ]</code>：定义弹性盒子元素的默认基准值。</li></ul><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://www.github.com/junjieweb/Front-end-Developer/edit/main/notes/css.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 90107547+junjieweb@users.noreply.github.com">Junjie</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/Front-end-Developer/notes/html.html" class="" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a></span><span class="next"><a href="/Front-end-Developer/notes/js.html" class="" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/Front-end-Developer/assets/app.c6770391.js" defer></script>
  </body>
</html>
